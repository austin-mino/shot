<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>shot game</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; user-select: none; touch-action: none; font-family: 'Segoe UI', sans-serif; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        /* ì •ë°€ í¬ë¡œìŠ¤í—¤ì–´ */
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 6px; height: 6px;
            background: #0f0; border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none;
            box-shadow: 0 0 4px #fff;
        }
        #crosshair-ring {
            position: absolute; top: 50%; left: 50%; width: 24px; height: 24px;
            border: 2px solid rgba(0, 255, 0, 0.5); border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none;
        }

        .hud-top { position: absolute; top: 20px; left: 20px; display: flex; gap: 15px; }
        .stat-box {
            background: rgba(0, 0, 0, 0.6); color: white; padding: 10px 20px;
            border-radius: 8px; font-size: 18px; font-weight: bold;
            border: 1px solid rgba(255,255,255,0.3); backdrop-filter: blur(4px);
        }
        #hp-bar { color: #ff4444; border-bottom: 3px solid #ff4444; }
        #score-bar { color: #44ff44; border-bottom: 3px solid #44ff44; }

        #boss-ui {
            display: none; position: absolute; top: 80px; left: 50%; transform: translateX(-50%);
            width: 50%; height: 25px; background: #222; border: 2px solid white; border-radius: 12px; overflow: hidden;
            box-shadow: 0 0 15px rgba(255,0,0,0.5);
        }
        #boss-hp-fill { width: 100%; height: 100%; background: linear-gradient(90deg, #ff0000, #ff5500); transition: width 0.1s; }
        #boss-msg { position: absolute; top: 55px; left: 50%; transform: translateX(-50%); color: red; font-weight: bold; display: none; text-shadow: 1px 1px 0 #000; animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0; } }

        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); display: flex; flex-direction: column;
            justify-content: center; align-items: center; color: white; z-index: 20; pointer-events: auto;
        }
        
        #game-over {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.95); flex-direction: column;
            justify-content: center; align-items: center; z-index: 100; pointer-events: auto;
        }
        button { padding: 15px 50px; font-size: 22px; cursor: pointer; border-radius: 50px; border:none; font-weight: bold; background: white; transition: 0.2s; }
        button:hover { background: #ff3333; color: white; transform: scale(1.05); }

        .mobile-controls { display: none; pointer-events: auto; }
        #joystick-zone { position: absolute; bottom: 50px; left: 40px; width: 140px; height: 140px; background: rgba(255,255,255,0.1); border-radius: 50%; border: 2px solid rgba(255,255,255,0.3); }
        #joystick-knob { position: absolute; top: 50%; left: 50%; width: 60px; height: 60px; background: rgba(255,255,255,0.8); border-radius: 50%; transform: translate(-50%, -50%); }
        .action-btn { position: absolute; width: 75px; height: 75px; border-radius: 50%; background: rgba(255,255,255,0.2); border: 2px solid white; color: white; display: flex; justify-content: center; align-items: center; font-weight: bold; font-size: 16px; user-select: none; }
        .action-btn:active { background: rgba(255,255,255,0.5); transform: scale(0.95); }
        #btn-jump { bottom: 60px; right: 40px; }
        #btn-fire { bottom: 160px; right: 100px; background: rgba(255,50,50,0.4); border-color: #ff5555; }
        #btn-cam { top: 20px; right: 20px; width: 60px; height: 60px; font-size: 14px; }

        #damage-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle, transparent 40%, red 120%); opacity: 0; pointer-events: none; transition: opacity 0.1s; z-index: 5; }
    </style>
</head>
<body>
    <div id="ui-layer">
        <div id="crosshair"></div>
        <div id="crosshair-ring"></div>
        <div class="hud-top">
            <div class="stat-box" id="hp-bar">HP: 100</div>
            <div class="stat-box" id="score-bar">SCORE: 0</div>
        </div>
        
        <div id="boss-msg">âš  WARNING: BOSS DETECTED âš </div>
        <div id="boss-ui"><div id="boss-hp-fill"></div><div id="boss-phase"
     style="position:absolute; width:100%; text-align:center;
            color:white; font-weight:bold; line-height:25px;">
    PHASE 1
</div>
</div>

        <div class="mobile-controls">
            <div id="joystick-zone"><div id="joystick-knob"></div></div>
            <div id="btn-fire" class="action-btn">FIRE</div>
            <div id="btn-jump" class="action-btn">JUMP</div>
            <div id="btn-cam" class="action-btn">CAM</div>
        </div>
    </div>

    <div id="damage-overlay"></div>

    <div id="start-screen">
        <h1 style="font-size: 40px; margin-bottom: 10px; color:#44ff44;">SYSTEM READY</h1>
        <p class="blink" style="margin-bottom: 30px;">TAP SCREEN TO START</p>
        <div style="text-align: center; color: #aaa; font-size: 14px; line-height: 1.6;">
            [PC] WASD: Move | SPACE: Jump | P: View Mode<br>
            MOUSE: Look | TAP/CLICK: Fire<br>
            (Fixed Aiming & Camera)
        </div>
    </div>

    <div id="game-over">
        <h1 style="color:red; font-size:60px; margin:0;">MISSION FAILED</h1>
        <p style="color:white; font-size:30px;">Final Score: <span id="final-score">0</span></p>
        <button onclick="location.reload()">REBOOT SYSTEM</button>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        let isFiring = false;
        let fireCooldown = 0;

        // --- 1. ì„¤ì • ë° ìƒíƒœ ---
        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        if (isMobile) {
            document.querySelector('.mobile-controls').style.display = 'block';
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('crosshair').style.display = 'none';
            document.getElementById('crosshair-ring').style.display = 'none';
        }

        const state = {
            hp: 100, score: 0, isGameOver: false, isGameActive: false,
            bossSpawned: false, nextBossScore: 5000,
            bullets: [], enemies: [], obstacles: [], debris: [],
                gunnerCount: 0, // âœ… ì´ ì¤„ ì¶”ê°€
cameraMode: 'TPS', 
            // êµ¬ë©´ ì¢Œí‘œê³„ ì‚¬ìš© (phi: ìˆ˜ì§, theta: ìˆ˜í‰)
            cam: { theta: Math.PI, phi: 1.4, radius: 4.5 } 
        };

        const input = { w: false, a: false, s: false, d: false, space: false, joyX: 0, joyY: 0 };
        const physics = { gravity: -0.018, jump: 0.45 };

        // --- 2. ì”¬ & ë Œë”ëŸ¬ ---
        const scene = new THREE.Scene();
        const colliders = { floors: [], walls: [] };
        scene.background = new THREE.Color(0x1b2a4a);
        scene.fog = new THREE.FogExp2(0x1b2a4a, 0.004);

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 500);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

       scene.add(new THREE.HemisphereLight(0x88aaff, 0x222233, 0.8));

const arenaLight = new THREE.PointLight(0x00ffff, 1.2, 120);
arenaLight.position.set(0, 30, 0);
scene.add(arenaLight);

const warmLight = new THREE.PointLight(0xff8844, 0.6, 80);
warmLight.position.set(40, 20, 40);
scene.add(warmLight);

        const dirLight = new THREE.DirectionalLight(0xffeedd, 1.2);
        dirLight.position.set(50, 100, 50); dirLight.castShadow = true;
        dirLight.shadow.mapSize.set(2048, 2048);
        scene.add(dirLight);
        // â­ ì „ì²´ ë°ê¸° ë³´ì •ìš© í•„ë¼ì´íŠ¸
const fillLight = new THREE.AmbientLight(0x8899ff, 0.35);
scene.add(fillLight);


       

        // --- 3. ìºë¦­í„° ìƒì„± ---
        function createDetailedHumanoid(color, isPlayer, scale = 1) {
            const group = new THREE.Group();
            
            const armorMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.3, metalness: 0.5 });
            const jointMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8 });
            const glowMat = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 0.5 });

            // ìƒì²´
            const torsoGroup = new THREE.Group();
            torsoGroup.position.y = 1.1;
            
            const chest = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.4, 0.35), armorMat);
            chest.position.y = 0.2; chest.castShadow = true;
            const core = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.15, 0.05), glowMat);
            core.position.set(0, 0.2, 0.18); chest.add(core);
            torsoGroup.add(chest);

            const abs = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.3, 0.25), jointMat);
            abs.position.y = -0.15; abs.castShadow = true; torsoGroup.add(abs);

            const backpack = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.5, 0.15), armorMat);
            backpack.position.set(0, 0.1, -0.25); torsoGroup.add(backpack);
            group.add(torsoGroup);

            // ë¨¸ë¦¬
            const headGroup = new THREE.Group();
            headGroup.position.set(0, 0.5, 0);
            const headMesh = new THREE.Mesh(new THREE.BoxGeometry(0.32, 0.35, 0.35), armorMat);
            headMesh.castShadow = true; headGroup.add(headMesh);
            const visor = new THREE.Mesh(new THREE.BoxGeometry(0.33, 0.12, 0.2), glowMat);
            visor.position.set(0, 0.05, 0.1); headGroup.add(visor);
            torsoGroup.add(headGroup);

            // íŒ”ë‹¤ë¦¬
            function createLimb(x, y, isLeg) {
                const root = new THREE.Group(); root.position.set(x, y, 0);
                const joint = new THREE.Mesh(new THREE.SphereGeometry(isLeg?0.13:0.12), jointMat); root.add(joint);
                const upper = new THREE.Mesh(new THREE.BoxGeometry(0.16, isLeg?0.45:0.35, 0.16), armorMat);
                upper.position.y = isLeg?-0.25:-0.2; upper.castShadow = true; joint.add(upper);
                const midJoint = new THREE.Mesh(new THREE.SphereGeometry(0.11), jointMat);
                midJoint.position.y = isLeg?-0.25:-0.2; upper.add(midJoint);
                const lower = new THREE.Mesh(new THREE.BoxGeometry(0.15, isLeg?0.45:0.35, 0.15), armorMat);
                lower.position.y = isLeg?-0.25:-0.2; lower.castShadow = true; midJoint.add(lower);
                return { root, upper: joint, lower: midJoint };
            }

            const lArm = createLimb(-0.42, 1.45, false); const rArm = createLimb(0.42, 1.45, false);
            const lLeg = createLimb(-0.22, 0.8, true); const rLeg = createLimb(0.22, 0.8, true);
            group.add(lArm.root); group.add(rArm.root); group.add(lLeg.root); group.add(rLeg.root);

            if (isPlayer) {
                const gun = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.2, 0.6), new THREE.MeshStandardMaterial({color: 0x222222}));
                gun.position.set(0, -0.2, 0.2); rArm.lower.add(gun); group.userData.gunTip = gun;
            } else {
                const blade = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.5, 0.05), new THREE.MeshStandardMaterial({color: 0xff3333, emissive: 0x990000}));
                blade.position.set(0, -0.2, 0.2); blade.rotation.x = Math.PI/2; rArm.lower.add(blade); group.userData.gunTip = blade;
            }

            group.userData = {
                lArm, rArm, lLeg, rLeg, torso: torsoGroup,
                hp: 100, maxHp: 100, velocity: new THREE.Vector3(), isGrounded: false,
                boxSize: new THREE.Vector3(0.6 * scale, 1.8 * scale, 0.6 * scale)
            };
            group.scale.set(scale, scale, scale);
            return group;
        }

        const player = createDetailedHumanoid(0x0088ff, true);
        player.position.set(0, 5, 0); // ğŸ”¥ footHeightë³´ë‹¤ ë†’ê²Œ
player.userData.velocity.y = 0; // ğŸ”’ ì´ˆê¸° ë‚™í•˜ ì°¨ë‹¨

        scene.add(player);
function box(w, h, d, x, y, z) {
    const geo = new THREE.BoxGeometry(w, h, d);
    const mat = new THREE.MeshStandardMaterial({ color: 0x555555 });
    const mesh = new THREE.Mesh(geo, mat);

    mesh.position.set(x, y, z);
    mesh.castShadow = true;
    mesh.receiveShadow = true;

    scene.add(mesh);

    // ë°”ë‹¥ íŒì •ìš©
    colliders.floors.push(mesh);

    return mesh;
}


// ==========================================
// â›©ï¸ ì˜¤ë²„ì›Œì¹˜ ë¶€ì‚° ë§µ ìƒì„± í•¨ìˆ˜ (í†µí•©í˜•)
// ==========================================
function createBusanMap() {
    console.log("â›©ï¸ Loading Busan Map...");

    // 1. ë¶€ì‚° í…Œë§ˆ ì¬ì§ˆ (Materials)
    const matFloor = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.8 }); // ì–´ë‘ìš´ ë°”ë‹¥
    const matWoodRed = new THREE.MeshStandardMaterial({ color: 0x8B0000, roughness: 0.6 }); // ë‹¨ì²­ ê¸°ë‘¥ (ì§„í•œ ë¹¨ê°•)
    const matRoofGreen = new THREE.MeshStandardMaterial({ color: 0x004d40, roughness: 0.5 }); // ì²­ê¸°ì™€
    const matWhiteWall = new THREE.MeshStandardMaterial({ color: 0xeeeeee, roughness: 0.2 }); // MEKA ê¸°ì§€ ë²½
    const matGlass = new THREE.MeshStandardMaterial({ color: 0x87CEEB, roughness: 0.1, transparent: true, opacity: 0.7 }); // ìœ ë¦¬
    const matNeon = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 0.8 }); // ë„¤ì˜¨ ì‚¬ì¸

    // 2. ë°”ë‹¥ ê¹”ê¸° (ê¸°ë³¸)
    const ground = new THREE.Mesh(new THREE.BoxGeometry(200, 1, 200), matFloor);
    ground.position.set(0, -0.5, 0);
    ground.receiveShadow = true;
    scene.add(ground);
    // (ë¬¼ë¦¬ ì—”ì§„ ë²„ì „ì— ë”°ë¼ colliders.floors í˜¹ì€ obstaclesì— ì¶”ê°€ í•„ìš”)
    if (typeof colliders !== 'undefined') colliders.floors.push(ground); 

    // === í—¬í¼ í•¨ìˆ˜: ë°•ìŠ¤ ìƒì„± ë° ì¶©ëŒ ë“±ë¡ ===
    function addBlock(x, y, z, w, h, d, mat, type = 'wall') {
        const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
        mesh.position.set(x, y + h / 2, z);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        
        // ì¶©ëŒ ë°•ìŠ¤ ë°ì´í„° ìƒì„± (ê¸°ì¡´ ì½”ë“œ í˜¸í™˜ìš©)
        mesh.userData.box = new THREE.Box3();
        mesh.geometry.computeBoundingBox();

        scene.add(mesh);

        // ì¶©ëŒ ë°°ì—´ì— ì¶”ê°€ (ì‚¬ìš©í•˜ëŠ” ë³€ìˆ˜ëª…ì— ë§ì¶° ìë™ ì²˜ë¦¬)
        if (typeof colliders !== 'undefined') {
            // ìˆ˜ì •ëœ ë¬¼ë¦¬ ì—”ì§„ ì‚¬ìš© ì‹œ
            if (type === 'wall') colliders.walls.push(mesh);
            else colliders.floors.push(mesh);
        } else if (typeof obstacles !== 'undefined') {
            // ì›ë³¸ ì½”ë“œ ì‚¬ìš© ì‹œ
            obstacles.push(mesh);
        }
    }

    // ==========================================
    // [êµ¬ì—­ A] ì‚¬ì°° (Sanctuary) - ë¶‰ì€ ê¸°ë‘¥ê³¼ ê¸°ì™€
    // ==========================================
    
    // ì…êµ¬ ê¸°ë‘¥ (Torii gate style)
    addBlock(-20, 0, -20, 2, 12, 2, matWoodRed); // ì¢Œ ê¸°ë‘¥
    addBlock(-10, 0, -20, 2, 12, 2, matWoodRed); // ìš° ê¸°ë‘¥
    addBlock(-15, 10, -20, 14, 2, 3, matRoofGreen); // ì§€ë¶• í”„ë ˆì„

    // ì‚¬ì°° ë²½ë©´ (ì—„íë¬¼)
    addBlock(-25, 0, -10, 2, 4, 15, matWoodRed);
    addBlock(-25, 0, -30, 2, 4, 15, matWoodRed);

    // ì¤‘ì•™ ê±°ì : ëŒ€í˜• ë¶ (The Drum) - ì›í†µí˜•ì´ì§€ë§Œ ì¶©ëŒì€ ë°•ìŠ¤ë¡œ ì²˜ë¦¬
    const drumGeo = new THREE.CylinderGeometry(4, 4, 5, 32);
    const drum = new THREE.Mesh(drumGeo, new THREE.MeshStandardMaterial({ color: 0xFFD700 }));
    drum.position.set(0, 2.5, 0);
    drum.castShadow = true;
    scene.add(drum);
    
    // ë¶ì˜ ì¶©ëŒì²´ (íˆ¬ëª… ë°•ìŠ¤)
    const drumCol = new THREE.Mesh(new THREE.BoxGeometry(8, 5, 8), new THREE.MeshBasicMaterial({ visible: false }));
    drumCol.position.set(0, 2.5, 0);
    if (typeof obstacles !== 'undefined') obstacles.push(drumCol);
    else if (typeof colliders !== 'undefined') colliders.walls.push(drumCol);


    // ==========================================
    // [êµ¬ì—­ B] ì‹œë‚´ (Downtown) - í˜„ëŒ€ì‹ ê±´ë¬¼ & 2ì¸µ
    // ==========================================

    // ì˜¤ë¥¸ìª½ 2ì¸µ ê±´ë¬¼ (ì €ê²© í¬ì¸íŠ¸)
    addBlock(25, 0, 0, 15, 8, 40, matWhiteWall); // 1ì¸µ ë²½ì²´
    addBlock(25, 8, 0, 15, 1, 40, matFloor, 'floor'); // 2ì¸µ ë°”ë‹¥

    // 2ì¸µ ë‚œê°„ (ìœ ë¦¬ ëŠë‚Œ)
    addBlock(18, 9, 0, 0.5, 3, 40, matGlass); 

    // ê³„ë‹¨ (Stairs) - ë¨í”„ ëŒ€ì‹  ê³„ë‹¨ ì‚¬ìš© (ì¶©ëŒ ì˜¤ë¥˜ ìµœì†Œí™”)
    // 2ì¸µìœ¼ë¡œ ì˜¬ë¼ê°€ëŠ” ê³„ë‹¨ì„ ì´˜ì´˜í•˜ê²Œ ë°°ì¹˜
    for(let i = 0; i < 10; i++) {
        // x: 18(ê±´ë¬¼ì•)ì—ì„œ ì‹œì‘, z: 20(ê±´ë¬¼ë) ìœ„ì¹˜
        addBlock(15, i * 0.8, 20 + (i * 1.5), 6, 1, 1.5, matWhiteWall, 'floor');
    }

    // ë„¤ì˜¨ ì‚¬ì¸ ê°„íŒ (ì—„íë¬¼)
    addBlock(10, 0, 10, 1, 5, 3, matNeon);
    addBlock(10, 0, -10, 1, 5, 3, matNeon);


    // ==========================================
    // [êµ¬ì—­ C] ì™¸ê³½ ê²½ê³„ (Map Bounds)
    // ==========================================
    const wallH = 15;
    addBlock(0, 0, 50, 100, wallH, 2, matWhiteWall); // ì•
    addBlock(0, 0, -50, 100, wallH, 2, matRoofGreen); // ë’¤ (ì‚¬ì°° ë°°ê²½)
    addBlock(-50, 0, 0, 2, wallH, 100, matWoodRed); // ì¢Œ
    addBlock(50, 0, 0, 2, wallH, 100, matWhiteWall); // ìš°

    // ì¡°ëª… ì¶”ê°€ (ë¶€ì‚°ì˜ ë°¤ ëŠë‚Œ)
    const pointLight = new THREE.PointLight(0x00ffff, 1, 50);
    pointLight.position.set(10, 10, 10);
    scene.add(pointLight);
}



        // --- 4. ì»¨íŠ¸ë¡¤ & ì¹´ë©”ë¼ ë¡œì§ ê°œì„  ---
        const startScreen = document.getElementById('start-screen');
        
        // ê²Œì„ ì‹œì‘
        startScreen.addEventListener('click', () => { 
            state.isGameActive = true; 
    player.userData.velocity.y = 0;   // ğŸ”’ ì¤‘ë ¥ ë¦¬ì…‹
    updateGround(player);             // â­ ë°”ë‹¥ì— ë”± ë¶™ì„

            document.body.requestPointerLock(); 
            startScreen.style.display = 'none';
        });

        document.addEventListener('pointerlockchange', () => {
            if (document.pointerLockElement === document.body) {
                state.isGameActive = true; startScreen.style.display = 'none';
            } else if (!state.isGameOver) {
                startScreen.style.display = 'flex';
            }
        });

        // [í•µì‹¬] ì¹´ë©”ë¼ íšŒì „ (êµ¬ë©´ ì¢Œí‘œê³„: Theta-ê°€ë¡œ, Phi-ì„¸ë¡œ)
        document.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement === document.body) {
                state.cam.theta -= e.movementX * 0.003; // ì¢Œìš°
                state.cam.phi -= e.movementY * 0.003;   // ìƒí•˜
                // ìˆ˜ì§ ê°ë„ ì œí•œ (ë„ˆë¬´ ìœ„/ì•„ë˜ë¡œ ëª» ê°€ê²Œ)
                state.cam.phi = Math.max(0.1, Math.min(Math.PI - 0.1, state.cam.phi));
            }
        });

        // [í•µì‹¬] ë°œì‚¬ (PointerDown ì´ë²¤íŠ¸ë¡œ í†µí•© - í„°ì¹˜íŒ¨ë“œ/í´ë¦­ ëª¨ë‘ ëŒ€ì‘)
       document.addEventListener('pointerdown', () => {
    if (state.isGameActive || isMobile) isFiring = true;
});
document.addEventListener('pointerup', () => {
    isFiring = false;
});


        window.addEventListener('keydown', e => {
    const k = e.key.toLowerCase();
    if (k === 'f') isFiring = true;
});

window.addEventListener('keyup', e => {
    const k = e.key.toLowerCase();
    if (k === 'f') isFiring = false;
});



        window.addEventListener('keydown', e => {
            const k = e.key.toLowerCase(); if (input.hasOwnProperty(k)) input[k] = true;
            if (e.code === 'Space') input.space = true;
            if (k === 'p') toggleCameraMode();
        });
        window.addEventListener('keyup', e => {
            const k = e.key.toLowerCase(); if (input.hasOwnProperty(k)) input[k] = false;
            if (e.code === 'Space') input.space = false;
        });

        // ëª¨ë°”ì¼ ì¡°ì´ìŠ¤í‹±
        const joy = { zone: document.getElementById('joystick-zone'), knob: document.getElementById('joystick-knob'), id: null, cx:0, cy:0 };
        joy.zone.addEventListener('touchstart', e => { e.preventDefault(); const t = e.changedTouches[0]; joy.id = t.identifier; const r = joy.zone.getBoundingClientRect(); joy.cx = r.left+r.width/2; joy.cy = r.top+r.height/2; updateJoy(t.clientX, t.clientY); });
        joy.zone.addEventListener('touchmove', e => { e.preventDefault(); for(let t of e.changedTouches) if(t.identifier===joy.id) updateJoy(t.clientX, t.clientY); });
        const endJoy = e => { for(let t of e.changedTouches) if(t.identifier===joy.id) { joy.id=null; joy.knob.style.transform=`translate(-50%,-50%)`; input.joyX=0; input.joyY=0; } };
        joy.zone.addEventListener('touchend', endJoy); joy.zone.addEventListener('touchcancel', endJoy);
        function updateJoy(x,y) {
            const dx = x-joy.cx, dy = y-joy.cy, d = Math.min(Math.sqrt(dx*dx+dy*dy), 60); const a = Math.atan2(dy,dx);
            joy.knob.style.transform = `translate(calc(-50% + ${Math.cos(a)*d}px), calc(-50% + ${Math.sin(a)*d}px))`;
            input.joyX = Math.cos(a)*(d/60); input.joyY = Math.sin(a)*(d/60);
        }
        document.getElementById('btn-jump').addEventListener('touchstart', e=>{e.preventDefault(); input.space=true;});
        document.getElementById('btn-jump').addEventListener('touchend', e=>{e.preventDefault(); input.space=false;});
        document.getElementById('btn-cam').addEventListener('touchstart', e=>{e.preventDefault(); toggleCameraMode();});
        document.getElementById('btn-fire').addEventListener('touchstart', e=>{
    e.preventDefault();
    isFiring = true;
});
document.getElementById('btn-fire').addEventListener('touchend', e=>{
    e.preventDefault();
    isFiring = false;
});


        function toggleCameraMode() {
            state.cameraMode = state.cameraMode === 'TPS' ? 'FPS' : 'TPS';
            player.visible = (state.cameraMode === 'TPS');
        }

        // ===== ë°”ë‹¥ ê°ì§€ (ê²½ì‚¬ / ì˜¤ë¥´ë§‰ / ë‚´ë¦¬ë§‰ ëŒ€ì‘) =====
const groundRay = new THREE.Raycaster();
const down = new THREE.Vector3(0, -1, 0);

function updateGround(player) {
    const footHeight = 1.6;

    // ğŸ”‘ ë°œ ìœ„ì¹˜ì—ì„œ ì‹œì‘
    const origin = player.position.clone();
    origin.y -= footHeight - 0.05;

    groundRay.set(origin, down);

    const hits = groundRay.intersectObjects(
        colliders.floors.filter(f => f.userData.isFloor),
        false
    );

    if (hits.length > 0) {
        const hit = hits[0];

        if (hit.distance <= 0.25 && player.userData.velocity.y <= 0) {
            player.position.y = hit.point.y + footHeight;
            player.userData.velocity.y = 0;
            player.userData.isGrounded = true;
            return;
        }
    }
    player.userData.isGrounded = false;
}

       function updateEnemyGround(enemy) {
    const footHeight = 1.6;

    const origin = enemy.position.clone();
    origin.y -= footHeight - 0.05;

    groundRay.set(origin, down);

    const hits = groundRay.intersectObjects(
        colliders.floors.filter(f => f.userData.isFloor),
        false
    );

    if (hits.length > 0) {
        const hit = hits[0];

        if (hit.distance <= 0.25 && enemy.userData.velocity.y <= 0) {
            enemy.position.y = hit.point.y + footHeight;
            enemy.userData.velocity.y = 0;
            enemy.userData.isGrounded = true;
            return;
        }
    }

    enemy.userData.isGrounded = false;
}



        // --- 5. ë¬¼ë¦¬ (ë²½ í†µê³¼ ë°©ì§€) ---
        function checkCollision(pos, boxSize) {
            const min = new THREE.Vector3(
    pos.x - boxSize.x/2,
    pos.y + 0.2,          // ğŸ”‘ ë°”ë‹¥ì€ ë¬´ì‹œ
    pos.z - boxSize.z/2
);
const max = new THREE.Vector3(
    pos.x + boxSize.x/2,
    pos.y + boxSize.y*0.5, // ğŸ”‘ í—ˆë¦¬ê¹Œì§€ë§Œ ê²€ì‚¬
    pos.z + boxSize.z/2
);

            const box = new THREE.Box3(min, max);
           for (const wall of colliders.walls) {
    wall.userData.box.copy(wall.geometry.boundingBox).applyMatrix4(wall.matrixWorld);
    if (box.intersectsBox(wall.userData.box)) {
        return { hit: true, box: wall.userData.box };
    }
}

            return { hit: false };
        }

        // --- 6. ê²Œì„ ë¡œì§ ---
        let boss = null;
        const clock = new THREE.Clock();
        const raycaster = new THREE.Raycaster();

        function fireBullet(isEnemy = false, origin = null, direction = null) {
    const color = isEnemy ? 0xff0000 : 0xffff00;
    const bullet = new THREE.Mesh(
        new THREE.BoxGeometry(0.08, 0.08, 0.6),
        new THREE.MeshBasicMaterial({ color })
    );

    let pos = new THREE.Vector3();
    let dir = new THREE.Vector3();

    if (origin && direction) {
        // ì  ë°œì‚¬
        pos.copy(origin);
        dir.copy(direction).normalize();
    } else {
      
// ===== í”Œë ˆì´ì–´ ë°œì‚¬ =====
pos.copy(player.position).add(new THREE.Vector3(0, 1.5, 0));

if (isMobile) {
    // ëª¨ë°”ì¼: ìºë¦­í„°ê°€ ë°”ë¼ë³´ëŠ” ë°©í–¥ìœ¼ë¡œ ë°œì‚¬
    dir.set(0, 0, -1).applyAxisAngle(
        new THREE.Vector3(0, 1, 0),
        player.rotation.y
    );
} else {
    // PC: í¬ë¡œìŠ¤í—¤ì–´ ì •ì¤‘ì•™ (ì™„ì „ ìˆ˜ë™ ì¡°ì¤€)
    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
    dir.copy(raycaster.ray.direction).normalize();
}


    }

    bullet.position.copy(pos);
    bullet.lookAt(pos.clone().add(dir));
    bullet.position.add(dir.clone().multiplyScalar(0.8));

    scene.add(bullet);

    state.bullets.push({
        mesh: bullet,
        velocity: dir.multiplyScalar(isEnemy ? 0.6 : 3.2),
        life: 90,
        isEnemy
    });
}

        function applyBossAppearance(boss) {
    let color;

    switch (boss.userData.type) {
        case 'tank':      // ğŸ”´ ë¬´ê±°ìš´ ë³´ìŠ¤
            color = 0xaa2222;
            break;
        case 'rush':      // âš¡ ë¹ ë¥¸ ë³´ìŠ¤
            color = 0x22aaff;
            break;
        case 'summoner':  // ğŸ§  ì†Œí™˜í˜•
            color = 0xaa22ff;
            break;
        default:
            color = 0xff0000;
    }

    boss.traverse(obj => {
        if (obj.isMesh && obj.material) {
            obj.material = obj.material.clone();
            obj.material.color.set(color);
            obj.material.emissive = new THREE.Color(color);
            obj.material.emissiveIntensity = 0.4;
        }
    });
}


   function spawnBoss() {
    // ì´ë¯¸ ë³´ìŠ¤ ìˆìœ¼ë©´ ì¤‘ë³µ ë°©ì§€
    if (state.bossSpawned) return;

    state.bossSpawned = true;

    // ë³´ìŠ¤ ìƒì„±
    boss = createDetailedHumanoid(0xff0000, false, 2.5);

    // ê¸°ë³¸ ìœ„ì¹˜
    boss.position.set(
        player.position.x + 40,
        10,
        player.position.z + 40
    );

    // ë³´ìŠ¤ ìŠ¤íƒ¯
    boss.userData.hp = 3000;
    boss.userData.maxHp = 3000;
    boss.userData.attackTimer = 0;
    boss.userData.phase = 1;
    boss.userData.lastPhase = 0;

       boss.userData.meleeCooldown = 0;
boss.userData.meleeRange = 3.5;
boss.userData.meleeDamage = 12;


    // ë³´ìŠ¤ íƒ€ì… ëœë¤
    const types = ['tank', 'rush', 'summoner'];
    boss.userData.type = types[Math.floor(Math.random() * types.length)];

    // ì™¸í˜• ì ìš©
    applyBossAppearance(boss);

    // ì”¬ ì¶”ê°€
    scene.add(boss);
boss.userData.velocity.y = 0;
updateGround(boss);

    // ===== UI =====
    document.getElementById('boss-ui').style.display = 'block';
    document.getElementById('boss-hp-fill').style.width = '100%';

    document.getElementById('boss-phase').innerText = 'PHASE 1';

    const msg = document.getElementById('boss-msg');
    msg.innerText = `âš  ${boss.userData.type.toUpperCase()} BOSS âš `;
    msg.style.display = 'block';

    setTimeout(() => {
        msg.style.display = 'none';
    }, 3000);
}



        function spawnDebris(pos, color) {
            for(let i=0; i<8; i++) {
                const m = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.2,0.2), new THREE.MeshBasicMaterial({color:color}));
                m.position.copy(pos); scene.add(m);
                state.debris.push({mesh:m, vel:new THREE.Vector3((Math.random()-0.5), Math.random(), (Math.random()-0.5)), life:40});
            }
        }

        function animate() {
requestAnimationFrame(animate);
                if (!state.isGameActive) return; // ğŸ”’ ì—¬ê¸°!!! í„°ì¹˜ ì „ì—” ê²Œì„ ì •ì§€
            if (state.isGameActive && !player.userData.isGrounded) {
    updateGround(player);
}



            // ì—°ì‚¬ ì²˜ë¦¬
if (isFiring && fireCooldown <= 0) {
    fireBullet();
    fireCooldown = 6; // ì‘ì„ìˆ˜ë¡ ì—°ì‚¬ ë¹ ë¦„
}
if (fireCooldown > 0) fireCooldown--;

            
            
            if (state.isGameOver) return;
            const dt = clock.getDelta();
            const time = clock.getElapsedTime();

            // 1. ì¹´ë©”ë¼ ì—…ë°ì´íŠ¸ (êµ¬ë©´ ê¶¤ë„)
            // ì¹´ë©”ë¼ ìœ„ì¹˜: í”Œë ˆì´ì–´ ë¨¸ë¦¬(ì¤‘ì‹¬) + êµ¬ë©´ ì¢Œí‘œ ì˜¤í”„ì…‹
            const targetPos = player.position.clone().add(new THREE.Vector3(0, 1.6, 0)); // ë¨¸ë¦¬ ì¤‘ì‹¬
            
            if (!isMobile) {
                // PC: ë§ˆìš°ìŠ¤ íšŒì „ì— ë”°ë¥¸ ê¶¤ë„ ê³„ì‚°
                // FPS ëª¨ë“œë©´ ë°˜ì§€ë¦„ 0
                const currentRadius = state.cameraMode === 'TPS' ? state.cam.radius : 0.1;
                
                // êµ¬ë©´ -> ì§êµ ë³€í™˜
                const offsetX = currentRadius * Math.sin(state.cam.phi) * Math.sin(state.cam.theta);
                const offsetY = currentRadius * Math.cos(state.cam.phi);
                const offsetZ = currentRadius * Math.sin(state.cam.phi) * Math.cos(state.cam.theta);
                
                camera.position.copy(targetPos).add(new THREE.Vector3(offsetX, offsetY, offsetZ));
                camera.lookAt(targetPos);

                // í”Œë ˆì´ì–´ íšŒì „ ë™ê¸°í™” (ì¹´ë©”ë¼ê°€ ë³´ëŠ” ìˆ˜í‰ ë°©í–¥ì„ ë´„)
                // ì¹´ë©”ë¼ëŠ” targetPosë¥¼ ë³´ë¯€ë¡œ, í”Œë ˆì´ì–´ëŠ” ì¹´ë©”ë¼ì˜ ë’¤ìª½(ë‚˜ë¥¼ ì°ëŠ” ë°©í–¥)ì˜ ë°˜ëŒ€, ì¦‰ ì¹´ë©”ë¼ê°€ ë³´ëŠ” ë°©í–¥ì„ ë´ì•¼ í•¨
                if (state.cameraMode === 'TPS' || state.cameraMode === 'FPS') {
                     // thetaê°€ 0ì¼ ë•Œ +Zë¥¼ ë´„ (Three.js ê¸°ë³¸). 
                     // ì¹´ë©”ë¼ëŠ” thetaì—ì„œ í”Œë ˆì´ì–´ë¥¼ ë´„. í”Œë ˆì´ì–´ëŠ” theta + PIë¥¼ ë´ì•¼ ì •ë©´.
                     player.rotation.y = state.cam.theta + Math.PI; 
                }
            } else {
                // ëª¨ë°”ì¼: ì¿¼í„°ë·°
                camera.position.lerp(player.position.clone().add(new THREE.Vector3(0, 15, 12)), 0.1);
                camera.lookAt(player.position);
            }

            // 2. ì´ë™ (í”Œë ˆì´ì–´ê°€ ë³´ëŠ” ë°©í–¥ ê¸°ì¤€)
            const fwd = new THREE.Vector3(0,0,1).applyAxisAngle(new THREE.Vector3(0,1,0), player.rotation.y);
            const right = new THREE.Vector3(-1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), player.rotation.y); // ì¢Œìš° ë°˜ì „ ì²´í¬
            
            const move = new THREE.Vector3();
            if(input.w) move.add(fwd); if(input.s) move.sub(fwd); 
            if(input.d) move.add(right); if(input.a) move.sub(right);
            
            if(isMobile && (input.joyX||input.joyY)) { 
                move.set(input.joyX, 0, input.joyY); 
                if(move.lengthSq() > 0.01) player.rotation.y = -Math.atan2(input.joyY, input.joyX) + Math.PI/2; 
            }
            
            move.normalize().multiplyScalar(0.25);

            player.position.x += move.x; if(checkCollision(player.position, player.userData.boxSize).hit) player.position.x -= move.x;
            player.position.z += move.z; if(checkCollision(player.position, player.userData.boxSize).hit) player.position.z -= move.z;

            // ì í”„ & ì¤‘ë ¥
           // ì í”„
// ===== ì í”„ =====
if (input.space && player.userData.isGrounded) {
    player.userData.velocity.y = physics.jump;
    player.userData.isGrounded = false;
}

// ===== ì¤‘ë ¥ =====
player.userData.velocity.y += physics.gravity;
player.position.y += player.userData.velocity.y;

// ===== ë°”ë‹¥ íŒì •ì€ í•­ìƒ ë§ˆì§€ë§‰ =====
updateGround(player);



            // 3. ì´ì•Œ ì—…ë°ì´íŠ¸
            for (let i = state.bullets.length - 1; i >= 0; i--) {
                const b = state.bullets[i]; b.mesh.position.add(b.velocity); b.life--;
                let hit = false;
                if(!hit) { for (const wall of colliders.walls) {
    wall.userData.box.copy(wall.geometry.boundingBox)
        .applyMatrix4(wall.matrixWorld);

    if (wall.userData.box.containsPoint(b.mesh.position)) {
        hit = true;
        break;
    }
}
 }
                if (!hit) {
                    if (b.isEnemy) { 
                        if(b.mesh.position.distanceTo(player.position.clone().add(new THREE.Vector3(0,1,0))) < 1.0) { state.hp -= 10; hit=true; document.getElementById('damage-overlay').style.opacity = 0.6; setTimeout(()=>document.getElementById('damage-overlay').style.opacity=0, 200); }
                    } else {
                        for(let j=state.enemies.length-1; j>=0; j--) {
                            if(state.enemies[j].position.distanceTo(b.mesh.position) < 1.5) { spawnDebris(state.enemies[j].position, 0xff4444); if (state.enemies[j].userData.isGunner) {
    state.gunnerCount--;
}
scene.remove(state.enemies[j]); state.enemies.splice(j,1); state.score+=100; hit=true; break; }
                        }
                        if(!hit && boss && boss.position.distanceTo(b.mesh.position) < 4) {
                            boss.userData.hp -= 20; hit=true; spawnDebris(b.mesh.position, 0xff0000); document.getElementById('boss-hp-fill').style.width = (boss.userData.hp/boss.userData.maxHp*100)+'%';
                           if (boss.userData.hp <= 0) {
    scene.remove(boss);
                              state.hp += 20;
state.hp = Math.min(state.hp, 100);


    boss = null;
    state.bossSpawned = false;

    document.getElementById('boss-ui').style.display = 'none';
}

                        }
                    }
                }
                if (hit || b.life <= 0) {
    scene.remove(b.mesh);
    state.bullets.splice(i, 1);
}

            }

            // ===== ë³´ìŠ¤ í˜ì´ì¦ˆ íŒì • =====
if (boss) {
    const hpRate = boss.userData.hp / boss.userData.maxHp;

    if (hpRate <= 0.3) boss.userData.phase = 3;
    else if (hpRate <= 0.7) boss.userData.phase = 2;
    else boss.userData.phase = 1;
}
if (boss) {
    if (boss.userData.lastPhase !== boss.userData.phase) {
        boss.userData.lastPhase = boss.userData.phase;

        // UI í…ìŠ¤íŠ¸
        document.getElementById('boss-phase').innerText =
            `PHASE ${boss.userData.phase}`;

        // ì²´ë ¥ë°” ìƒ‰ìƒ ë³€ê²½
        const fill = document.getElementById('boss-hp-fill');
        fill.style.background =
            boss.userData.phase === 1
                ? 'linear-gradient(90deg, #ff5555, #ff2222)'
                : boss.userData.phase === 2
                ? 'linear-gradient(90deg, #ffaa00, #ff7700)'
                : 'linear-gradient(90deg, #aa00ff, #ff00aa)';

        // âš  í˜ì´ì¦ˆ ì „í™˜ ë©”ì‹œì§€
        const msg = document.getElementById('boss-msg');
        msg.innerText = `âš  PHASE ${boss.userData.phase} âš `;
        msg.style.display = 'block';
        setTimeout(() => msg.style.display = 'none', 1500);
    }
}


            // 4. ì  ìŠ¤í° & AI
            if(state.score >= state.nextBossScore && !state.bossSpawned) { spawnBoss(); state.nextBossScore += 5000; }
           if(!boss && state.enemies.length < 15 && Math.random() < 0.03) {
    const e = createDetailedHumanoid(0xff4444, false);
    const a = Math.random()*6.28;
    const r = 30+Math.random()*20;

    // x,zë§Œ ì§€ì • (yëŠ” ìœ„ì—ì„œ ì‹œì‘)
    e.position.set(
        player.position.x + Math.cos(a) * r,
        20,
        player.position.z + Math.sin(a) * r
    );

    // ğŸ”’ í”Œë ˆì´ì–´ì™€ ë™ì¼ ì²˜ë¦¬
    e.userData.velocity.y = 0;
    updateGround(e);

                
                // ğŸ”« GUNNER ì„¤ì • (ìµœëŒ€ 3ëª…)
    if (state.gunnerCount < 3) {
        e.userData.isGunner = true;
        e.userData.shootCooldown = Math.random() * 1.5;
        state.gunnerCount++;

        // ìƒ‰ìœ¼ë¡œ êµ¬ë¶„
        e.traverse(obj => {
            if (obj.isMesh && obj.material) {
                obj.material = obj.material.clone();
                obj.material.color.set(0xffaa00);
            }
        });
    }
                scene.add(e); state.enemies.push(e);
            }
          


            const allEnemies = [...state.enemies]; if(boss) allEnemies.push(boss);
            allEnemies.forEach(e => {updateEnemyGround(e);
// ======================
// ğŸ”« GUNNER ENEMY ATTACK
// ======================
if (e !== boss && e.userData.isGunner) {
    e.userData.shootCooldown -= dt;

    if (e.userData.shootCooldown <= 0) {
        const dir = new THREE.Vector3()
            .subVectors(player.position, e.position)
            .normalize();

        fireBullet(
            true,
            e.position.clone().add(new THREE.Vector3(0, 1.6, 0)),
            dir
        );

        e.userData.shootCooldown = 2.2;
    }
}

                const dist = e.position.distanceTo(player.position); e.lookAt(player.position.x, e.position.y, player.position.z);
                if(dist > (e===boss?8:1.2)) {
                    const speed = e===boss ? 0.06 : 0.1; const moveDir = new THREE.Vector3(0,0,1).applyQuaternion(e.quaternion);
                    const oldX = e.position.x; e.position.x += moveDir.x * speed; if(checkCollision(e.position, e.userData.boxSize).hit) e.position.x = oldX;
                    const oldZ = e.position.z; e.position.z += moveDir.z * speed; if(checkCollision(e.position, e.userData.boxSize).hit) e.position.z = oldZ;
                }
              
if (e === boss) {
    e.userData.attackTimer += dt;
// ============================
// ğŸ‘Š BOSS MELEE ATTACK
// ============================
    const distToPlayer = e.position.distanceTo(player.position);

    if (distToPlayer < e.userData.meleeRange) {
        e.userData.meleeCooldown -= dt;

        if (e.userData.meleeCooldown <= 0) {
            // ğŸ’¥ ë°ë¯¸ì§€
            state.hp -= e.userData.meleeDamage * e.userData.phase;
const knockDir = new THREE.Vector3()
    .subVectors(player.position, e.position)
    .normalize()
    .multiplyScalar(0.8);
player.position.add(knockDir);

            // í”¼ê²© ì—°ì¶œ
            const overlay = document.getElementById('damage-overlay');
            overlay.style.opacity = 0.7;
            setTimeout(() => overlay.style.opacity = 0, 200);

            // ì¿¨íƒ€ì„ ë¦¬ì…‹
            e.userData.meleeCooldown = 1.2;

            // ê°„ë‹¨í•œ íƒ€ê²© ëª¨ì…˜
            e.userData.rArm.root.rotation.x = -1.5;
            setTimeout(() => {
                e.userData.rArm.root.rotation.x = 0;
            }, 200);
        }
    }
}

    const phase = e.userData.phase;
    const type = e.userData.type;

    const attackDelay =
        phase === 1 ? 2.5 :
        phase === 2 ? 1.6 : 0.9;

    if (e.userData.attackTimer > attackDelay) {
        e.userData.attackTimer = 0;

        // ======================
        // ğŸ”´ TANK BOSS
        // ======================
        if (type === 'tank') {
            const count = phase === 1 ? 6 : phase === 2 ? 10 : 16;
            const spread = Math.PI / 3;

            for (let i = 0; i < count; i++) {
                const angle =
                    -spread / 2 + (spread / count) * i +
                    e.rotation.y;

                fireBullet(
                    true,
                    e.position.clone().add(new THREE.Vector3(0, 1.6, 0)),
                    new THREE.Vector3(Math.sin(angle), 0, Math.cos(angle))
                );
            }
        }

        // ======================
        // âš¡ RUSH BOSS
        // ======================
        if (type === 'rush') {
            const dir = new THREE.Vector3()
                .subVectors(player.position, e.position)
                .normalize();

            const rushMove = dir.multiplyScalar(phase * 3);
const oldPos = e.position.clone();
e.position.add(rushMove);

if (checkCollision(e.position, e.userData.boxSize).hit) {
    e.position.copy(oldPos);
}

        }

        // ======================
        // ğŸ§  SUMMONER BOSS
        // ======================
        if (type === 'summoner') {
            const spawnCount = phase;

            for (let i = 0; i < spawnCount; i++) {
                const minion = createDetailedHumanoid(0xff7777, false);
                minion.position.copy(e.position).add(
                    new THREE.Vector3(
                        (Math.random() - 0.5) * 6,
                        0,
                        (Math.random() - 0.5) * 6
                    )
                );
                scene.add(minion);
                state.enemies.push(minion);
            }
        }

        // ğŸ¥ í˜ì´ì¦ˆ 3 ì—°ì¶œ
        if (phase === 3) {
            camera.position.add(
                new THREE.Vector3(
                    (Math.random() - 0.5) * 0.4,
                    (Math.random() - 0.5) * 0.4,
                    0
                )
            );
        }
    }
                                     
                               
                               
                else {
                    if(dist < 1.2) { state.hp -= 0.5; document.getElementById('damage-overlay').style.opacity = 0.3; }
                }
                const anim = time * (e===boss?4:10);
                e.userData.lArm.root.rotation.x = -Math.sin(anim); e.userData.rArm.root.rotation.x = Math.sin(anim);
                e.userData.lLeg.root.rotation.x = Math.sin(anim); e.userData.rLeg.root.rotation.x = -Math.sin(anim);
            });

            if(state.hp <= 0) { state.isGameOver = true; document.getElementById('game-over').style.display = 'flex'; document.getElementById('final-score').innerText = state.score; document.exitPointerLock(); }

            for(let i=state.debris.length-1; i>=0; i--) { const d=state.debris[i]; d.mesh.position.add(d.vel); d.vel.y-=0.02; d.life--; if(d.life<=0){scene.remove(d.mesh); state.debris.splice(i,1);} }
            document.getElementById('hp-bar').innerText = `HP: ${Math.floor(state.hp)}`; document.getElementById('score-bar').innerText = `SCORE: ${state.score}`;
            
            if(input.w||input.s||input.a||input.d || (isMobile&&(input.joyX||input.joyY))) {
                const at = time * 15;
                player.userData.lArm.root.rotation.x = -Math.sin(at); player.userData.rArm.root.rotation.x = Math.sin(at);
                player.userData.lLeg.root.rotation.x = Math.sin(at); player.userData.rLeg.root.rotation.x = -Math.sin(at);
            }
            renderer.render(scene, camera);
        }
        animate();
        window.addEventListener('resize', () => { camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    </script>
</body>
</html>
