<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Final Android Shooter v2.0</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; user-select: none; touch-action: none; }
        
        /* UI 레이어 */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
        }

        /* 상단 HUD */
        .hud-top {
            position: absolute; top: 20px; left: 20px;
            display: flex; gap: 15px;
        }
        .stat-box {
            background: rgba(0, 0, 0, 0.6); color: white; padding: 10px 20px;
            border-radius: 8px; font-family: 'Segoe UI', sans-serif;
            font-size: 18px; font-weight: bold; border: 1px solid rgba(255,255,255,0.2);
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        #hp-bar { color: #ff4444; border-bottom: 3px solid #ff4444; }
        #score-bar { color: #44ff44; border-bottom: 3px solid #44ff44; }
        #boss-hp-container {
            display: none; position: absolute; top: 80px; left: 50%; transform: translateX(-50%);
            width: 60%; height: 20px; background: #333; border: 2px solid white; border-radius: 10px; overflow: hidden;
        }
        #boss-hp-fill { width: 100%; height: 100%; background: #ff0000; transition: width 0.2s; }
        #boss-label { position: absolute; top: -25px; left: 0; width: 100%; text-align: center; color: red; font-weight: bold; text-shadow: 1px 1px 0 black; }

        /* 게임 오버 화면 */
        #game-over {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9); flex-direction: column;
            justify-content: center; align-items: center; z-index: 100; pointer-events: auto;
        }
        h1 { color: #ff3333; font-size: 60px; margin: 0; text-transform: uppercase; letter-spacing: 5px; }
        p { color: white; font-size: 24px; margin: 20px 0; }
        .btn {
            padding: 15px 40px; font-size: 20px; cursor: pointer; background: white;
            border: none; border-radius: 50px; font-weight: bold; transition: 0.3s;
        }
        .btn:active { transform: scale(0.95); }

        /* 모바일 컨트롤러 */
        .mobile-controls {
            display: none; /* JS에서 모바일 감지 시 block으로 변경 */
            pointer-events: auto;
        }
        #joystick-zone {
            position: absolute; bottom: 50px; left: 50px; width: 120px; height: 120px;
            background: rgba(255, 255, 255, 0.1); border-radius: 50%; border: 2px solid rgba(255,255,255,0.3);
        }
        #joystick-knob {
            position: absolute; top: 50%; left: 50%; width: 50px; height: 50px;
            background: rgba(255, 255, 255, 0.8); border-radius: 50%; transform: translate(-50%, -50%);
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        .action-btn {
            position: absolute; width: 80px; height: 80px; border-radius: 50%;
            background: rgba(255, 255, 255, 0.2); border: 2px solid white; color: white;
            font-weight: bold; font-size: 16px; display: flex; justify-content: center; align-items: center;
            user-select: none;
        }
        .action-btn:active { background: rgba(255, 255, 255, 0.5); transform: scale(0.95); }
        #btn-jump { bottom: 60px; right: 40px; }
        #btn-fire { bottom: 160px; right: 100px; background: rgba(255, 50, 50, 0.3); border-color: #ff5555; }

        /* 피격 오버레이 */
        #damage-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 50%, red 100%);
            opacity: 0; transition: opacity 0.2s; pointer-events: none; z-index: 5;
        }
    </style>
</head>
<body>
    <div id="ui-layer">
        <div class="hud-top">
            <div class="stat-box" id="hp-bar">HP: 100</div>
            <div class="stat-box" id="score-bar">SCORE: 0</div>
            <div class="stat-box" style="font-size: 14px; color: #ccc;">NEXT BOSS: <span id="boss-timer">15000</span></div>
        </div>
        
        <div id="boss-hp-container">
            <div id="boss-label">⚠ WARNING: BOSS APPROACHING ⚠</div>
            <div id="boss-hp-fill"></div>
        </div>

        <div class="mobile-controls">
            <div id="joystick-zone"><div id="joystick-knob"></div></div>
            <div id="btn-fire" class="action-btn">FIRE</div>
            <div id="btn-jump" class="action-btn">JUMP</div>
        </div>
    </div>

    <div id="damage-overlay"></div>

    <div id="game-over">
        <h1>MISSION FAILED</h1>
        <p>Final Score: <span id="final-score">0</span></p>
        <button class="btn" onclick="location.reload()">RESTART SYSTEM</button>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- 1. 전역 설정 및 변수 ---
        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        if (isMobile) document.querySelector('.mobile-controls').style.display = 'block';

        let hp = 100;
        let score = 0;
        let isGameOver = false;
        let bossSpawned = false;
        let nextBossScore = 15000;
        let boss = null;

        const bullets = [];
        const enemies = [];
        const debrisList = [];
        const obstacles = [];
        
        // 입력 상태
        const input = { x: 0, y: 0, jump: false, fire: false }; // x, y는 조이스틱 벡터
        const keys = { w: false, a: false, s: false, d: false, space: false };
        let mousePressed = false;

        // 물리 상수
        const GRAVITY = -0.018;
        const JUMP_POWER = 0.45;
        const PLAYER_SPEED = 0.25;

        // --- 2. Three.js 초기화 ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        scene.fog = new THREE.FogExp2(0x111111, 0.025);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 500);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // 조명
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
        scene.add(hemiLight);
        const dirLight = new THREE.DirectionalLight(0xffeedd, 1.5);
        dirLight.position.set(50, 80, 50);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.set(2048, 2048);
        dirLight.shadow.camera.left = -100; dirLight.shadow.camera.right = 100;
        dirLight.shadow.camera.top = 100; dirLight.shadow.camera.bottom = -100;
        scene.add(dirLight);

        // 바닥
        const plane = new THREE.Mesh(
            new THREE.PlaneGeometry(500, 500),
            new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 })
        );
        plane.rotation.x = -Math.PI / 2;
        plane.receiveShadow = true;
        scene.add(plane);
        
        // 그리드 헬퍼 (바닥 느낌)
        const grid = new THREE.GridHelper(500, 100, 0x444444, 0x111111);
        scene.add(grid);

        // --- 3. 모델링 함수 (디테일 업그레이드) ---
        function createAdvancedHumanoid(color, isPlayer, scale = 1) {
            const group = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.3, metalness: 0.6 });
            const jointMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.9 });

            // 몸통
            const torso = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.7, 0.3), mat);
            torso.position.y = 1.1; torso.castShadow = true; group.add(torso);
            
            // 백팩 (디테일)
            const backpack = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.5, 0.15), new THREE.MeshStandardMaterial({color: 0x333333}));
            backpack.position.set(0, 0.1, -0.25); torso.add(backpack);

            // 머리
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.35, 0.35), mat);
            head.position.y = 0.6; torso.add(head);
            
            // 바이저 (눈)
            const visor = new THREE.Mesh(new THREE.BoxGeometry(0.36, 0.12, 0.2), new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 0.8 }));
            visor.position.set(0, 0.05, 0.1); head.add(visor);

            function createLimb(w, h, d, x, y, z) {
                const pivot = new THREE.Group();
                pivot.position.set(x, y, z);
                const limb = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
                limb.position.y = -h / 2; limb.castShadow = true;
                
                // 관절 표현
                const joint = new THREE.Mesh(new THREE.SphereGeometry(w*0.8), jointMat);
                joint.position.y = 0; pivot.add(joint);
                
                pivot.add(limb); group.add(pivot);
                return pivot;
            }

            const leftArm = createLimb(0.15, 0.7, 0.15, -0.35, 1.4, 0);
            const rightArm = createLimb(0.15, 0.7, 0.15, 0.35, 1.4, 0);
            const leftLeg = createLimb(0.18, 0.8, 0.18, -0.15, 0.8, 0);
            const rightLeg = createLimb(0.18, 0.8, 0.18, 0.15, 0.8, 0);

            if (isPlayer) {
                const gun = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.15, 0.6), new THREE.MeshStandardMaterial({ color: 0x222222 }));
                gun.position.set(0, -0.6, 0.3); rightArm.add(gun);
                group.userData.gunTip = gun;
            } else {
                 // 적 무기
                 const blade = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.5, 0.1), new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x550000 }));
                 blade.position.set(0, -0.6, 0.2); blade.rotation.x = Math.PI/2; rightArm.add(blade);
            }

            group.userData = { leftLeg, rightLeg, leftArm, rightArm, torso };
            group.scale.set(scale, scale, scale);
            
            // AABB(충돌 박스) 계산을 위한 사이즈 설정
            group.userData.width = 0.6 * scale;
            group.userData.height = 1.8 * scale;
            group.userData.velocity = new THREE.Vector3();
            group.userData.isGrounded = false;
            
            return group;
        }

        // --- 4. 장애물 생성 (밟을 수 있음) ---
        function createObstacles() {
            for(let i=0; i<40; i++) {
                const w = 2 + Math.random() * 3;
                const h = 1 + Math.random() * 4;
                const d = 2 + Math.random() * 3;
                const geo = new THREE.BoxGeometry(w, h, d);
                const mat = new THREE.MeshStandardMaterial({ color: 0x555566 });
                const mesh = new THREE.Mesh(geo, mat);
                
                mesh.position.set( (Math.random()-0.5)*200, h/2, (Math.random()-0.5)*200 );
                mesh.castShadow = true; mesh.receiveShadow = true;
                
                // 충돌 검사를 위한 데이터
                mesh.userData.box = new THREE.Box3().setFromObject(mesh);
                scene.add(mesh);
                obstacles.push(mesh);
            }
        }
        createObstacles();

        const player = createAdvancedHumanoid(0x0088ff, true);
        scene.add(player);

        // --- 5. 보스 시스템 ---
        function spawnBoss() {
            bossSpawned = true;
            boss = createAdvancedHumanoid(0xff0000, false, 4); // 4배 크기
            boss.position.set(player.position.x + 40, 0, player.position.z);
            boss.userData.hp = 1000;
            boss.userData.maxHp = 1000;
            boss.userData.attackTimer = 0;
            scene.add(boss);

            const ui = document.getElementById('boss-hp-container');
            ui.style.display = 'block';
            updateBossUI();
        }

        function updateBossUI() {
            if(!boss) return;
            const fill = document.getElementById('boss-hp-fill');
            fill.style.width = `${(boss.userData.hp / boss.userData.maxHp) * 100}%`;
        }

        function bossLogic(dt) {
            if (!boss) return;

            // 플레이어 바라보기
            boss.lookAt(player.position.x, boss.position.y, player.position.z);
            
            // 이동 (느리게 따라옴)
            const dir = new THREE.Vector3().subVectors(player.position, boss.position).normalize();
            boss.position.add(dir.multiplyScalar(0.08)); // 이동 속도
            animateHumanoid(boss, clock.getElapsedTime(), true);

            boss.userData.attackTimer += dt;
            
            // 패턴 공격
            if (boss.userData.attackTimer > 3.0) { // 3초마다 공격
                boss.userData.attackTimer = 0;
                const pattern = Math.floor(Math.random() * 3);
                
                if (pattern === 0) { // 원형 탄막
                    for(let i=0; i<16; i++) {
                        const angle = (Math.PI * 2 / 16) * i;
                        shootBullet(boss.position.clone().add(new THREE.Vector3(0,5,0)), 
                                    new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle)), false);
                    }
                } else if (pattern === 1) { // 3연발 조준 사격
                    setTimeout(() => bossShootAtPlayer(), 0);
                    setTimeout(() => bossShootAtPlayer(), 200);
                    setTimeout(() => bossShootAtPlayer(), 400);
                } else { // 소환
                    const minion = createAdvancedHumanoid(0xffaaaa, false, 1);
                    minion.position.copy(boss.position).add(new THREE.Vector3(Math.random()*5, 0, Math.random()*5));
                    enemies.push(minion); scene.add(minion);
                }
            }
        }

        function bossShootAtPlayer() {
            if (!boss || isGameOver) return;
            const dir = new THREE.Vector3().subVectors(player.position, boss.position).normalize();
            shootBullet(boss.position.clone().add(new THREE.Vector3(0,5,0)), dir, false);
        }

        // --- 6. 입력 처리 (키보드 + 모바일) ---
        // 키보드
        window.addEventListener('keydown', e => { 
            if(keys.hasOwnProperty(e.key.toLowerCase())) keys[e.key.toLowerCase()] = true; 
            if(e.code === 'Space') keys.space = true;
        });
        window.addEventListener('keyup', e => { 
            if(keys.hasOwnProperty(e.key.toLowerCase())) keys[e.key.toLowerCase()] = false; 
            if(e.code === 'Space') keys.space = false;
        });
        window.addEventListener('mousedown', () => mousePressed = true);
        window.addEventListener('mouseup', () => mousePressed = false);

        // 모바일 터치
        const joystick = { zone: document.getElementById('joystick-zone'), knob: document.getElementById('joystick-knob'), active: false, origin: {x:0, y:0}, ptrId: null };
        
        joystick.zone.addEventListener('touchstart', e => {
            e.preventDefault();
            const touch = e.changedTouches[0];
            joystick.ptrId = touch.identifier;
            joystick.active = true;
            const rect = joystick.zone.getBoundingClientRect();
            joystick.origin = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
            updateJoystick(touch.clientX, touch.clientY);
        }, {passive: false});

        joystick.zone.addEventListener('touchmove', e => {
            e.preventDefault();
            if(!joystick.active) return;
            for(let i=0; i<e.changedTouches.length; i++) {
                if(e.changedTouches[i].identifier === joystick.ptrId) {
                    updateJoystick(e.changedTouches[i].clientX, e.changedTouches[i].clientY);
                    break;
                }
            }
        }, {passive: false});

        const endJoystick = (e) => {
             for(let i=0; i<e.changedTouches.length; i++) {
                if(e.changedTouches[i].identifier === joystick.ptrId) {
                    joystick.active = false;
                    joystick.knob.style.transform = `translate(-50%, -50%)`;
                    input.x = 0; input.y = 0;
                }
            }
        };
        joystick.zone.addEventListener('touchend', endJoystick);
        joystick.zone.addEventListener('touchcancel', endJoystick);

        function updateJoystick(x, y) {
            const dx = x - joystick.origin.x;
            const dy = y - joystick.origin.y;
            const distance = Math.min(Math.sqrt(dx*dx + dy*dy), 40);
            const angle = Math.atan2(dy, dx);
            
            joystick.knob.style.transform = `translate(calc(-50% + ${Math.cos(angle)*distance}px), calc(-50% + ${Math.sin(angle)*distance}px))`;
            
            // Normalize input -1 to 1
            input.x = Math.cos(angle) * (distance / 40);
            input.y = Math.sin(angle) * (distance / 40);
        }

        document.getElementById('btn-jump').addEventListener('touchstart', (e) => { e.preventDefault(); input.jump = true; });
        document.getElementById('btn-jump').addEventListener('touchend', (e) => { e.preventDefault(); input.jump = false; });
        document.getElementById('btn-fire').addEventListener('touchstart', (e) => { e.preventDefault(); input.fire = true; });
        document.getElementById('btn-fire').addEventListener('touchend', (e) => { e.preventDefault(); input.fire = false; });

        // --- 7. 메인 로직 함수들 ---

        function shootBullet(pos, dir, isPlayerBullet) {
            const bullet = new THREE.Mesh(
                new THREE.BoxGeometry(0.2, 0.2, 0.6), 
                new THREE.MeshBasicMaterial({ color: isPlayerBullet ? 0xffff00 : 0xff0000 })
            );
            bullet.position.copy(pos);
            bullet.lookAt(pos.clone().add(dir));
            scene.add(bullet);
            bullets.push({ mesh: bullet, velocity: dir.multiplyScalar(isPlayerBullet ? 1.5 : 0.6), life: 80, isPlayer: isPlayerBullet });
        }

        // 마우스 조준 (PC용)
        const raycaster = new THREE.Raycaster();
        const mouseVec = new THREE.Vector2();
        const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
        
        window.addEventListener('mousemove', e => {
            if(isMobile) return;
            mouseVec.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouseVec.y = -(e.clientY / window.innerHeight) * 2 + 1;
        });

        function updatePlayerAim() {
            if (isMobile) {
                // 이동 방향을 보거나, 자동 조준 (가장 가까운 적)
                if (enemies.length > 0 || boss) {
                    let target = boss;
                    if (!target) {
                        let minIds = Infinity;
                        enemies.forEach(e => {
                            const d = player.position.distanceTo(e.position);
                            if(d < minIds) { minIds = d; target = e; }
                        });
                    }
                    if(target) player.lookAt(target.position.x, player.position.y, target.position.z);
                } else if (input.x !== 0 || input.y !== 0) {
                     // 적이 없으면 이동 방향 봄
                     const angle = Math.atan2(input.y, input.x);
                     player.rotation.y = -angle + Math.PI/2; // Three.js 좌표계 보정
                }
            } else {
                // PC 마우스 조준
                raycaster.setFromCamera(mouseVec, camera);
                const target = new THREE.Vector3();
                raycaster.ray.intersectPlane(groundPlane, target);
                if (target) player.lookAt(target.x, player.position.y, target.z);
            }
        }

        function spawnEnemy() {
            if (isGameOver || bossSpawned || enemies.length > 20) return;
            const enemy = createAdvancedHumanoid(0xff4444, false);
            const angle = Math.random() * Math.PI * 2;
            const dist = 40 + Math.random() * 20;
            enemy.position.set(player.position.x + Math.cos(angle)*dist, 0, player.position.z + Math.sin(angle)*dist);
            scene.add(enemy);
            enemies.push(enemy);
        }
        setInterval(spawnEnemy, 1500);

        function checkCollisionAABB(object, dy) {
            // 간단한 AABB 충돌 구현 (y축 이동 후 충돌하는지 확인)
            const playerBox = new THREE.Box3().setFromObject(object);
            playerBox.min.y += dy; playerBox.max.y += dy;
            
            // 더 작게 만듦 (관대하게)
            playerBox.min.x += 0.2; playerBox.max.x -= 0.2;
            playerBox.min.z += 0.2; playerBox.max.z -= 0.2;

            for (const obs of obstacles) {
                if (playerBox.intersectsBox(obs.userData.box)) {
                    // 위에서 떨어지는 중이고, 플레이어의 발이 장애물의 위에 있다면 착지
                    if (dy < 0 && object.position.y > obs.position.y) {
                         return { collision: true, type: 'floor', y: obs.userData.box.max.y };
                    }
                    return { collision: true, type: 'wall' };
                }
            }
            return { collision: false };
        }

        function shakeCamera() {
            camera.position.x += (Math.random()-0.5) * 0.5;
            camera.position.y += (Math.random()-0.5) * 0.5;
            camera.position.z += (Math.random()-0.5) * 0.5;
        }

        function spawnDebris(pos, color) {
            for(let i=0; i<8; i++) {
                const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.2,0.2), new THREE.MeshBasicMaterial({color:color}));
                mesh.position.copy(pos);
                mesh.userData.vel = new THREE.Vector3((Math.random()-0.5), Math.random(), (Math.random()-0.5));
                scene.add(mesh); debrisList.push(mesh);
            }
        }

        // --- 8. 게임 루프 ---
        const clock = new THREE.Clock();
        let fireCooldown = 0;

        function animate() {
            requestAnimationFrame(animate);
            if(isGameOver) return;
            
            const dt = clock.getDelta();
            const time = clock.getElapsedTime();

            // 1. 플레이어 이동 및 물리
            let moveX = 0, moveZ = 0;
            if(keys.w) moveZ = -1; if(keys.s) moveZ = 1;
            if(keys.a) moveX = -1; if(keys.d) moveX = 1;
            
            // 모바일 입력 합산
            moveX += input.x; moveZ += input.y;

            // 이동 처리
            if(moveX !== 0 || moveZ !== 0) {
                const moveVec = new THREE.Vector3(moveX, 0, moveZ).normalize().multiplyScalar(PLAYER_SPEED);
                // X축 이동 체크
                player.position.x += moveVec.x;
                if(checkCollisionAABB(player, 0).collision) player.position.x -= moveVec.x;
                // Z축 이동 체크
                player.position.z += moveVec.z;
                if(checkCollisionAABB(player, 0).collision) player.position.z -= moveVec.z;
                
                animateHumanoid(player, time, true);
            } else {
                animateHumanoid(player, time, false);
            }

            // 점프 및 중력
            if ((keys.space || input.jump) && player.userData.isGrounded) {
                player.userData.velocity.y = JUMP_POWER;
                player.userData.isGrounded = false;
            }

            player.userData.velocity.y += GRAVITY;
            const nextY = player.userData.velocity.y;
            const col = checkCollisionAABB(player, nextY);

            if (col.collision && col.type === 'floor') {
                player.position.y = col.y;
                player.userData.velocity.y = 0;
                player.userData.isGrounded = true;
            } else if (player.position.y + nextY < 0) { // 바닥
                player.position.y = 0;
                player.userData.velocity.y = 0;
                player.userData.isGrounded = true;
            } else {
                player.position.y += nextY;
                player.userData.isGrounded = false;
            }

            // 조준 및 발사
            updatePlayerAim();
            if ((mousePressed || input.fire) && fireCooldown <= 0) {
                const gunPos = new THREE.Vector3();
                player.userData.gunTip.getWorldPosition(gunPos);
                // 총알 방향: 플레이어가 보는 방향
                const dir = new THREE.Vector3(0,0,1).applyQuaternion(player.quaternion);
                shootBullet(gunPos, dir, true);
                fireCooldown = 10; // 발사 딜레이
                shakeCamera(); // 반동
            }
            if(fireCooldown > 0) fireCooldown--;

            // 2. 보스 로직
            if (!bossSpawned && score >= nextBossScore) {
                spawnBoss();
                nextBossScore += 15000;
            }
            if (boss) bossLogic(dt);

            // 3. 총알 업데이트
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                b.mesh.position.add(b.velocity);
                b.life--;
                
                let hit = false;
                
                if (b.isPlayer) {
                    // 적 명중
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        if (b.mesh.position.distanceTo(enemies[j].position.clone().add(new THREE.Vector3(0,1,0))) < 1.0) {
                            spawnDebris(enemies[j].position, 0xff4444);
                            scene.remove(enemies[j]); enemies.splice(j, 1);
                            score += 500; 
                            hit = true; break;
                        }
                    }
                    // 보스 명중
                    if (!hit && boss && b.mesh.position.distanceTo(boss.position.clone().add(new THREE.Vector3(0,3,0))) < 3.0) {
                        boss.userData.hp -= 20;
                        updateBossUI();
                        spawnDebris(b.mesh.position, 0xff0000);
                        hit = true;
                        if(boss.userData.hp <= 0) {
                            spawnDebris(boss.position, 0xff0000);
                            scene.remove(boss); boss = null; bossSpawned = false;
                            document.getElementById('boss-hp-container').style.display = 'none';
                            score += 5000;
                        }
                    }
                } else {
                    // 플레이어 명중 (적 총알)
                    if (b.mesh.position.distanceTo(player.position.clone().add(new THREE.Vector3(0,1,0))) < 0.8) {
                        takeDamage();
                        hit = true;
                    }
                }

                // 장애물 충돌
                if (!hit) {
                     for(const obs of obstacles) {
                         if(obs.userData.box.containsPoint(b.mesh.position)) {
                             hit = true; break;
                         }
                     }
                }

                if (hit || b.life <= 0) {
                    scene.remove(b.mesh);
                    bullets.splice(i, 1);
                }
            }

            // 4. 적 업데이트 (플레이어 추적)
            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                const dist = e.position.distanceTo(player.position);
                e.lookAt(player.position);
                
                if (dist > 1.2) {
                    e.position.add(new THREE.Vector3(0,0,1).applyQuaternion(e.quaternion).multiplyScalar(0.08));
                    animateHumanoid(e, time, true);
                } else {
                    takeDamage();
                    e.position.add(new THREE.Vector3(0,0,-1).applyQuaternion(e.quaternion).multiplyScalar(2.0)); // 넉백
                }
                
                // 적 중력 (간단히)
                if(e.position.y > 0) e.position.y -= 0.1; 
                else e.position.y = 0;
            }

            // 5. 파편 물리
            for(let i=debrisList.length-1; i>=0; i--) {
                const d = debrisList[i];
                d.position.add(d.userData.vel);
                d.userData.vel.y -= 0.05; // 중력
                d.rotation.x += 0.1;
                if(d.position.y < -5) { scene.remove(d); debrisList.splice(i,1); }
            }

            // UI 업데이트
            document.getElementById('hp-bar').innerText = `HP: ${hp}`;
            document.getElementById('score-bar').innerText = `SCORE: ${score}`;
            document.getElementById('boss-timer').innerText = bossSpawned ? "ACTIVE!" : nextBossScore;

            // 카메라 팔로우 (부드럽게)
            const targetPos = player.position.clone().add(new THREE.Vector3(0, 18, 14)); // 쿼터뷰 각도 조정
            camera.position.lerp(targetPos, 0.1);
            camera.lookAt(player.position);

            renderer.render(scene, camera);
        }

        function animateHumanoid(obj, t, isMoving) {
            const data = obj.userData;
            if(!isMoving) {
                data.leftLeg.rotation.x = data.rightLeg.rotation.x = 0;
                data.leftArm.rotation.x = data.rightArm.rotation.x = 0;
                return;
            }
            const angle = Math.sin(t * 12) * 0.8;
            data.leftLeg.rotation.x = angle;
            data.rightLeg.rotation.x = -angle;
            data.leftArm.rotation.x = -angle * 0.6;
            data.rightArm.rotation.x = angle * 0.6;
        }

        function takeDamage() {
            if(isGameOver) return;
            hp -= 10;
            const overlay = document.getElementById('damage-overlay');
            overlay.style.opacity = 0.8;
            setTimeout(() => overlay.style.opacity = 0, 300);
            shakeCamera();
            
            if (hp <= 0) {
                isGameOver = true;
                document.getElementById('game-over').style.display = 'flex';
                document.getElementById('final-score').innerText = score;
            }
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
