<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>shot game</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; user-select: none; touch-action: none; font-family: 'Segoe UI', sans-serif; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        /* 정밀 크로스헤어 */
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 6px; height: 6px;
            background: #0f0; border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none;
            box-shadow: 0 0 4px #fff;
        }
        #crosshair-ring {
            position: absolute; top: 50%; left: 50%; width: 24px; height: 24px;
            border: 2px solid rgba(0, 255, 0, 0.5); border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none;
        }

        .hud-top { position: absolute; top: 20px; left: 20px; display: flex; gap: 15px; }
        .stat-box {
            background: rgba(0, 0, 0, 0.6); color: white; padding: 10px 20px;
            border-radius: 8px; font-size: 18px; font-weight: bold;
            border: 1px solid rgba(255,255,255,0.3); backdrop-filter: blur(4px);
        }
        #hp-bar { color: #ff4444; border-bottom: 3px solid #ff4444; }
        #score-bar { color: #44ff44; border-bottom: 3px solid #44ff44; }
        

        #boss-ui {
            display: none; position: absolute; top: 80px; left: 50%; transform: translateX(-50%);
            width: 50%; height: 25px; background: #222; border: 2px solid white; border-radius: 12px; overflow: hidden;
            box-shadow: 0 0 15px rgba(255,0,0,0.5);
        }
        #boss-hp-fill { width: 100%; height: 100%; background: linear-gradient(90deg, #ff0000, #ff5500); transition: width 0.1s; }
        #boss-msg { position: absolute; top: 55px; left: 50%; transform: translateX(-50%); color: red; font-weight: bold; display: none; text-shadow: 1px 1px 0 #000; animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0; } }

        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); display: flex; flex-direction: column;
            justify-content: center; align-items: center; color: white; z-index: 20; pointer-events: auto;
        }
        
        #game-over {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.95); flex-direction: column;
            justify-content: center; align-items: center; z-index: 100; pointer-events: auto;
        }
        button { padding: 15px 50px; font-size: 22px; cursor: pointer; border-radius: 50px; border:none; font-weight: bold; background: white; transition: 0.2s; }
        button:hover { background: #ff3333; color: white; transform: scale(1.05); }

        .mobile-controls { display: none; pointer-events: auto; }
        #joystick-zone { position: absolute; bottom: 50px; left: 40px; width: 140px; height: 140px; background: rgba(255,255,255,0.1); border-radius: 50%; border: 2px solid rgba(255,255,255,0.3); }
        #joystick-knob { position: absolute; top: 50%; left: 50%; width: 60px; height: 60px; background: rgba(255,255,255,0.8); border-radius: 50%; transform: translate(-50%, -50%); }
        .action-btn { position: absolute; width: 75px; height: 75px; border-radius: 50%; background: rgba(255,255,255,0.2); border: 2px solid white; color: white; display: flex; justify-content: center; align-items: center; font-weight: bold; font-size: 16px; user-select: none; }
        .action-btn:active { background: rgba(255,255,255,0.5); transform: scale(0.95); }
        #btn-jump { bottom: 60px; right: 40px; }
        #btn-fire { bottom: 160px; right: 100px; background: rgba(255,50,50,0.4); border-color: #ff5555; }
        #btn-cam { top: 20px; right: 20px; width: 60px; height: 60px; font-size: 14px; }

        #damage-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle, transparent 40%, red 120%); opacity: 0; pointer-events: none; transition: opacity 0.1s; z-index: 5; }
    </style>
</head>
<body>
    <div id="ui-layer">
        <div id="crosshair"></div>
        <div id="crosshair-ring"></div>
        <div class="hud-top">
            <div class="stat-box" id="hp-bar">HP: 100</div>
            <div class="stat-box" id="score-bar">SCORE: 0</div>
        </div>
        <div id="ammo-ui" style="position: absolute; bottom: 50px; right: 50px; color: #00ff00; font-size: 32px; font-weight: bold; text-shadow: 0 0 5px #000;">
    30 / ∞
</div>
<div id="reload-msg" style="position: absolute; top: 60%; left: 50%; transform: translate(-50%, -50%); color: #ff3333; font-size: 24px; font-weight: bold; display: none;">
    RELOADING...
</div>
        <div id="boss-msg">⚠ WARNING: BOSS DETECTED ⚠</div>
        <div id="boss-ui"><div id="boss-hp-fill"></div><div id="boss-phase"
     style="position:absolute; width:100%; text-align:center;
            color:white; font-weight:bold; line-height:25px;">
    PHASE 1
</div>
</div>

        <div class="mobile-controls">
            <div id="joystick-zone"><div id="joystick-knob"></div></div>
            <div id="btn-fire" class="action-btn">FIRE</div>
            <div id="btn-jump" class="action-btn">JUMP</div>
            <div id="btn-cam" class="action-btn">CAM</div>
        </div>
    </div>

    <div id="damage-overlay"></div>

    <div id="start-screen">
        <h1 style="font-size: 40px; margin-bottom: 10px; color:#44ff44;">SYSTEM READY</h1>
        <p class="blink" style="margin-bottom: 30px;">TAP SCREEN TO START</p>
        <div style="text-align: center; color: #aaa; font-size: 14px; line-height: 1.6;">
            [PC] WASD: Move | SPACE: Jump | P: View Mode<br>
            MOUSE: Look | TAP/CLICK: Fire<br>
            (Fixed Aiming & Camera)
        </div>
    </div>

    <div id="game-over">
        <h1 style="color:red; font-size:60px; margin:0;">MISSION FAILED</h1>
        <p style="color:white; font-size:30px;">Final Score: <span id="final-score">0</span></p>
        <button onclick="location.reload()">REBOOT SYSTEM</button>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        let isFiring = false;
        let fireCooldown = 0;

        // --- 1. 설정 및 상태 ---
        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        if (isMobile) {
            document.querySelector('.mobile-controls').style.display = 'block';
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('crosshair').style.display = 'none';
            document.getElementById('crosshair-ring').style.display = 'none';
        }

        const state = {
            hp: 100, 
            score: 0, 
            isGameOver: false, 
            isGameActive: false,
            bossSpawned: false, 
            nextBossScore: 4000,
            bullets: [], 
            enemies: [], 
            obstacles: [], 
            debris: [],
            gunnerCount: 0, // ✅ 이 줄 추가
            cameraMode: 'TPS', 
            ammo: 30,          // 현재 탄창에 남은 총알
            maxAmmo: 30,       // 탄창 용량
            isReloading: false, // 재장전 중인지 여부
            currentWeapon: 'rifle', // 'rifle' 또는 'knife'
            isSwinging: false,      // 칼 휘두르는 중인지 확인 (연타 방지)
            // 구면 좌표계 사용 (phi: 수직, theta: 수평)
            cam: { theta: Math.PI, phi: 1.4, radius: 4.5 } 
        
        };

        const input = { w: false, a: false, s: false, d: false, space: false, joyX: 0, joyY: 0 };
        const physics = { gravity: -0.019, jump: 0.45 };


// [추가] 광선검 생성 및 플레이어 오른팔에 부착 함수
function attachWeaponsToPlayer() {
    // 1. 플레이어의 오른팔 찾기 (createDetailedHumanoid 구조 기준)
    const rightArm = player.userData.rArm.root; 

    // --- (1) 기존 총기 모델이 있다면 찾아서 태그 달기 ---
    // (만약 기존 코드에 총 모델이 따로 없다면, 간단히 박스로 총을 만들어서 붙여도 됩니다.
    //  여기서는 기존에 총을 쏘던 손을 '소총 모드'로 가정합니다.)
    
    // --- (2) 근접 무기 (광선검) 생성 ---
    const hiltGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.3, 8);
    const hiltMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
    const hilt = new THREE.Mesh(hiltGeo, hiltMat);
    
    // 칼날 (빛나는 네온)
    const bladeGeo = new THREE.BoxGeometry(0.1, 1.2, 0.05);
    const bladeMat = new THREE.MeshStandardMaterial({ 
        color: 0x00ffff, 
        emissive: 0x00ffff, 
        emissiveIntensity: 2.0 
    });
    const blade = new THREE.Mesh(bladeGeo, bladeMat);
    blade.position.y = 0.75; // 손잡이 위로

    // 무기 그룹
    const knifeGroup = new THREE.Group();
    knifeGroup.add(hilt);
    knifeGroup.add(blade);

    // 위치 잡기 (손에 쥐어주기)
    knifeGroup.position.set(0, -0.2, 0.3); // 손 위치에 맞게 조정
    knifeGroup.rotation.x = Math.PI / 2;   // 앞으로 뻗게
    
    // 처음엔 숨김
    knifeGroup.visible = false; 
    
    // 참조 저장
    player.userData.knife = knifeGroup; 
    
    // 오른팔에 부착
    rightArm.add(knifeGroup);
}

// [중요] 게임 초기화 부분(createGround 등 호출하는 곳)에서 이 함수를 한번 호출해야 합니다!
// 예: createPlayer() 호출 직후
// attachWeaponsToPlayer(); <-- 이 줄을 init 부분에 넣으세요.

        
        function reloadWeapon() {
    // 이미 재장전 중이거나, 총알이 꽉 차있으면 무시
    if (state.isReloading || state.ammo === state.maxAmmo) return;

    state.isReloading = true;
    
    // UI 업데이트 (재장전 중 표시)
    document.getElementById('reload-msg').style.display = 'block';
    document.getElementById('ammo-ui').innerText = "RELOADING...";
    document.getElementById('ammo-ui').style.color = "#ff3333"; // 빨간색 경고

    // 1.5초 후 재장전 완료
    setTimeout(() => {
        state.ammo = state.maxAmmo;
        state.isReloading = false;

        // UI 복구
        document.getElementById('reload-msg').style.display = 'none';
        updateAmmoUI(); 
    }, 1500); // 1.5초 걸림 (원하는 시간으로 조절 가능)
}

function updateAmmoUI() {
    const el = document.getElementById('ammo-ui');
    el.innerText = `${state.ammo} / ∞`;
    el.style.color = state.ammo <= 5 ? "#ff3333" : "#00ff00"; // 5발 이하면 빨간색
}

        // --- 2. 씬 & 렌더러 ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1b2a4a);
        scene.fog = new THREE.FogExp2(0x1b2a4a, 0.004);

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 500);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

       scene.add(new THREE.HemisphereLight(0x88aaff, 0x222233, 0.8));

const arenaLight = new THREE.PointLight(0x00ffff, 1.2, 120);
arenaLight.position.set(0, 30, 0);
scene.add(arenaLight);

const warmLight = new THREE.PointLight(0xff8844, 0.6, 80);
warmLight.position.set(40, 20, 40);
scene.add(warmLight);

        const dirLight = new THREE.DirectionalLight(0xffeedd, 1.2);
        dirLight.position.set(50, 100, 50); dirLight.castShadow = true;
        dirLight.shadow.mapSize.set(2048, 2048);
        scene.add(dirLight);
        // ⭐ 전체 밝기 보정용 필라이트
const fillLight = new THREE.AmbientLight(0x8899ff, 0.35);
scene.add(fillLight);


       

        // --- 3. 캐릭터 생성 ---
        function createDetailedHumanoid(color, isPlayer, scale = 1) {
            const group = new THREE.Group();
            
            const armorMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.3, metalness: 0.5 });
            const jointMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8 });
            const glowMat = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 0.5 });

            // 상체
            const torsoGroup = new THREE.Group();
            torsoGroup.position.y = 1.1;
            
            const chest = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.4, 0.35), armorMat);
            chest.position.y = 0.2; chest.castShadow = true;
            const core = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.15, 0.05), glowMat);
            core.position.set(0, 0.2, 0.18); chest.add(core);
            torsoGroup.add(chest);

            const abs = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.3, 0.25), jointMat);
            abs.position.y = -0.15; abs.castShadow = true; torsoGroup.add(abs);

            const backpack = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.5, 0.15), armorMat);
            backpack.position.set(0, 0.1, -0.25); torsoGroup.add(backpack);
            group.add(torsoGroup);

            // 머리
            const headGroup = new THREE.Group();
            headGroup.position.set(0, 0.5, 0);
            const headMesh = new THREE.Mesh(new THREE.BoxGeometry(0.32, 0.35, 0.35), armorMat);
            headMesh.castShadow = true; headGroup.add(headMesh);
            const visor = new THREE.Mesh(new THREE.BoxGeometry(0.33, 0.12, 0.2), glowMat);
            visor.position.set(0, 0.05, 0.1); headGroup.add(visor);
            torsoGroup.add(headGroup);

            // 팔다리
            function createLimb(x, y, isLeg) {
                const root = new THREE.Group(); root.position.set(x, y, 0);
                const joint = new THREE.Mesh(new THREE.SphereGeometry(isLeg?0.13:0.12), jointMat); root.add(joint);
                const upper = new THREE.Mesh(new THREE.BoxGeometry(0.16, isLeg?0.45:0.35, 0.16), armorMat);
                upper.position.y = isLeg?-0.25:-0.2; upper.castShadow = true; joint.add(upper);
                const midJoint = new THREE.Mesh(new THREE.SphereGeometry(0.11), jointMat);
                midJoint.position.y = isLeg?-0.25:-0.2; upper.add(midJoint);
                const lower = new THREE.Mesh(new THREE.BoxGeometry(0.15, isLeg?0.45:0.35, 0.15), armorMat);
                lower.position.y = isLeg?-0.25:-0.2; lower.castShadow = true; midJoint.add(lower);
                return { root, upper: joint, lower: midJoint };
            }

            const lArm = createLimb(-0.42, 1.45, false); const rArm = createLimb(0.42, 1.45, false);
            const lLeg = createLimb(-0.22, 0.8, true); const rLeg = createLimb(0.22, 0.8, true);
            group.add(lArm.root); group.add(rArm.root); group.add(lLeg.root); group.add(rLeg.root);

            if (isPlayer) {
                const gun = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.2, 0.6), new THREE.MeshStandardMaterial({color: 0x222222}));
                gun.position.set(0, -0.2, 0.2); rArm.lower.add(gun); group.userData.gunTip = gun;
            } else {
                const blade = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.5, 0.05), new THREE.MeshStandardMaterial({color: 0xff3333, emissive: 0x990000}));
                blade.position.set(0, -0.2, 0.2); blade.rotation.x = Math.PI/2; rArm.lower.add(blade); group.userData.gunTip = blade;
            }

           group.userData = {
    lArm, rArm, lLeg, rLeg, torso: torsoGroup,
    hp: 100,
    maxHp: 100,
    velocity: new THREE.Vector3(),
    isGrounded: false
};

// ✅ 여기서 따로
if (isPlayer) {
    group.userData.collider = {
        radius: 0.45,
        height: 1.7
    };
}

            group.scale.set(scale, scale, scale);
            return group;
        }

        const player = createDetailedHumanoid(0x0088ff, true);
    

        scene.add(player);
function box(w, h, d, x, y, z) {
    const geo = new THREE.BoxGeometry(w, h, d);
    const mat = new THREE.MeshStandardMaterial({ color: 0x555555 });
    const mesh = new THREE.Mesh(geo, mat);

    mesh.position.set(x, y, z);
    mesh.castShadow = true;
    mesh.receiveShadow = true;

    scene.add(mesh);

    // 바닥 판정용
    colliders.floors.push(mesh);

    return mesh;
}

       

// 플레이어 초기화 (velocity & grounded)
if (!player.userData.velocity) {
    player.userData.velocity = { x: 0, y: 0, z: 0 };
    player.userData.isGrounded = false;
}


/* ===============================
   기본 설정
================================ */

const colliders = { floors: [], walls: [] };

const groundY = 18.4;
const spacing = 25;
const viewDistance = 3;

const MAP_SIZE = 500;
const MAP_HALF = MAP_SIZE / 2;
const WALL_HEIGHT = 80;
const WALL_THICKNESS = 10;

const generatedPositions = new Set();

/* ===============================
   환경 (미래형 폐허 분위기)
================================ */

scene.background = new THREE.Color(0x050508); 
scene.fog = new THREE.FogExp2(0x0a0a10, 0.0025); 

const ambientLight = new THREE.AmbientLight(0x222222, 2); 
scene.add(ambientLight);

const moonLight = new THREE.DirectionalLight(0xaaccff, 0.5);
moonLight.position.set(-50, 100, 50);
moonLight.castShadow = true;
scene.add(moonLight);

/* ===============================
   전체 바닥
================================ */

function createGround(size = 500) {
    const mat = new THREE.MeshStandardMaterial({
        color: 0x1a1a1a, 
        roughness: 0.9,
        metalness: 0.2
    });

    const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(size, size),
        mat
    );

    ground.rotation.x = -Math.PI / 2;
    ground.position.y = groundY;
    ground.receiveShadow = true;
    ground.userData.isFloor = true;

    colliders.floors.push(ground);
    scene.add(ground);
}

createGround(MAP_SIZE);

/* ===============================
   맵 경계 벽
================================ */

function createMapBoundaryWalls() {
    const mat = new THREE.MeshStandardMaterial({
        color: 0x0f0f0f,
        roughness: 0.4,
        metalness: 0.8,
        emissive: 0x110000,
        emissiveIntensity: 0.2
    });

    function makeWall(w, h, d, x, y, z) {
        const wall = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            mat
        );
        wall.position.set(x, y, z);
        wall.castShadow = true;
        wall.receiveShadow = true;
        wall.geometry.computeBoundingBox();
        wall.userData.box = new THREE.Box3().setFromObject(wall);

        colliders.walls.push(wall);
        scene.add(wall);
    }

    const y = groundY + WALL_HEIGHT / 2;
    makeWall(MAP_SIZE + WALL_THICKNESS * 2, WALL_HEIGHT, WALL_THICKNESS, 0, y, MAP_HALF + WALL_THICKNESS / 2);
    makeWall(MAP_SIZE + WALL_THICKNESS * 2, WALL_HEIGHT, WALL_THICKNESS, 0, y, -MAP_HALF - WALL_THICKNESS / 2);
    makeWall(WALL_THICKNESS, WALL_HEIGHT, MAP_SIZE, MAP_HALF + WALL_THICKNESS / 2, y, 0);
    makeWall(WALL_THICKNESS, WALL_HEIGHT, MAP_SIZE, -MAP_HALF - WALL_THICKNESS / 2, y, 0);
}

createMapBoundaryWalls();

/* ===============================
   유틸리티: 랜덤 잔해 생성기 (개수 대폭 감소)
================================ */
function createDebris(x, z, radius, count) {
    const debrisColors = [0x888888, 0x666666, 0x555555, 0x333333];
    
    for(let i=0; i<count; i++) {
        const size = 0.5 + Math.random() * 1.0; // 크기도 약간 줄임
        const debrisMat = new THREE.MeshStandardMaterial({
            color: debrisColors[Math.floor(Math.random() * debrisColors.length)],
            roughness: 0.9
        });
        
        const mesh = new THREE.Mesh(new THREE.BoxGeometry(size, size, size), debrisMat);
        
        const r = Math.random() * radius;
        const theta = Math.random() * Math.PI * 2;
        const dx = r * Math.cos(theta);
        const dz = r * Math.sin(theta);
        
        mesh.position.set(x + dx, groundY + size/2, z + dz);
        mesh.rotation.set(Math.random(), Math.random(), Math.random());
        
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        
        mesh.geometry.computeBoundingBox();
        mesh.userData.box = new THREE.Box3().setFromObject(mesh);
        
        // 0.6 이상이면 바닥으로 인정
        if(size > 0.6) {
            mesh.userData.isFloor = true;
            colliders.floors.push(mesh);
        } 
        
        scene.add(mesh);
    }
}

/* ===============================
   건물 생성
================================ */

function createBuilding(x, z) {
    // 1. 미래적인 재질 설정 (어두운 바디 + 강렬한 네온)
    const bodyColor = 0x111111; // 거의 검은색에 가까운 금속
    const neonColors = [0x00ffff, 0xff00ff, 0x00ff00, 0xffaa00, 0xffffff]; // 사이버펑크 네온 팔레트
    const mainNeonColor = neonColors[Math.floor(Math.random() * neonColors.length)];

    // 건물 본체 재질 (어둡고 거친 금속 느낌)
    const wallMat = new THREE.MeshStandardMaterial({
        color: bodyColor,
        roughness: 0.2, // 약간 반들거림
        metalness: 0.8  // 금속성 강화
    });

    // 네온 재질 (강하게 빛남)
    const neonMat = new THREE.MeshStandardMaterial({
        color: mainNeonColor,
        emissive: mainNeonColor,
        emissiveIntensity: 2.0, // 강한 발광
        roughness: 0.0,
        metalness: 0.0
    });

    const floorMat = new THREE.MeshStandardMaterial({
        color: 0x050505,
        roughness: 0.9
    });

    // 2. 크기 랜덤 설정
    const width  = 10 + Math.random() * 6;
    const depth  = 10 + Math.random() * 6;
    const height = 15 + Math.random() * 25; // 더 높고 웅장하게

    // 3. 건물 본체 (물리 충돌체 역할)
    const building = new THREE.Mesh(
        new THREE.BoxGeometry(width, height, depth),
        wallMat
    );

    // 위치 설정
    building.position.set(x, groundY + height / 2, z);
    building.castShadow = true;
    building.receiveShadow = true;

    // --- [디테일 추가] 미래 도시 느낌 내기 ---
    
    // 스타일 랜덤 선택 (0: 수직 스트라이프, 1: 코너 기둥, 2: 랜덤 창문)
    const style = Math.floor(Math.random() * 3);

    if (style === 0) {
        // 스타일 1: 수직 네온 스트라이프 (Tron 스타일)
        const stripCount = 4;
        const stripGeo = new THREE.BoxGeometry(0.5, height, 0.5); // 얇은 기둥
        
        // 앞, 뒤, 좌, 우에 네온 기둥 박기
        for (let i = 0; i < stripCount; i++) {
            const strip = new THREE.Mesh(stripGeo, neonMat);
            
            // 건물 표면에 절반쯤 묻히게 배치
            if (i === 0) strip.position.set(0, 0, depth/2); // 앞
            if (i === 1) strip.position.set(0, 0, -depth/2); // 뒤
            if (i === 2) strip.position.set(width/2, 0, 0); // 우
            if (i === 3) strip.position.set(-width/2, 0, 0); // 좌
            
            building.add(strip); // 건물의 자식으로 추가 (같이 움직임)
        }
    } 
    else if (style === 1) {
        // 스타일 2: 코너 가드 (건물 모서리에 네온)
        const cornerGeo = new THREE.BoxGeometry(0.8, height, 0.8);
        const positions = [
            [width/2, depth/2], [width/2, -depth/2],
            [-width/2, depth/2], [-width/2, -depth/2]
        ];
        
        positions.forEach(pos => {
            const pillar = new THREE.Mesh(cornerGeo, neonMat);
            pillar.position.set(pos[0], 0, pos[1]);
            building.add(pillar);
        });
    } 
    else {
        // 스타일 3: 데이터 서버 스타일 (랜덤한 네온 점들)
        const windowSize = 0.5;
        const windowGeo = new THREE.BoxGeometry(windowSize, windowSize, 0.2);
        
        for (let i = 0; i < 10; i++) { // 면마다 10개 정도
            const win = new THREE.Mesh(windowGeo, neonMat);
            
            // 랜덤 면 선택 (앞/뒤/좌/우)
            const face = Math.floor(Math.random() * 4);
            const wX = (Math.random() - 0.5) * width * 0.8;
            const wY = (Math.random() - 0.5) * height * 0.8;
            const wZ = (Math.random() - 0.5) * depth * 0.8;

            if (face === 0) win.position.set(wX, wY, depth/2);
            else if (face === 1) win.position.set(wX, wY, -depth/2);
            else if (face === 2) win.position.set(width/2, wY, wZ);
            else win.position.set(-width/2, wY, wZ);

            if (face > 1) win.rotation.y = Math.PI / 2;
            
            building.add(win);
        }
    }

    // ------------------------------------

    // 물리 충돌 박스 등록 (본체 기준)
    building.updateMatrixWorld();
    building.geometry.computeBoundingBox();
    building.userData.box = new THREE.Box3().setFromObject(building);
    colliders.walls.push(building);
    scene.add(building);

    // 4. 옥상 (Roof) - 걷기용
    const roofThickness = 0.5;
    const roof = new THREE.Mesh(
        new THREE.BoxGeometry(width, roofThickness, depth),
        floorMat
    );
    roof.position.set(x, groundY + height, z);
    roof.receiveShadow = true;
    roof.userData.isFloor = true;
    
    // 옥상 테두리에 네온 두르기 (낙사 방지 가이드라인 역할도 함)
    const roofBorderGeo = new THREE.BoxGeometry(width + 0.2, 0.2, depth + 0.2);
    const roofBorder = new THREE.Mesh(roofBorderGeo, neonMat);
    roofBorder.position.y = 0; // roof 기준 로컬 0
    roof.add(roofBorder);

    roof.updateMatrixWorld();
    roof.geometry.computeBoundingBox();
    roof.userData.box = new THREE.Box3().setFromObject(roof);
    colliders.floors.push(roof);
    scene.add(roof);

    // 5. 경사로 연결 (기존 로직 유지)
    createRampToRoof(building, width, depth, height);

    // 6. 주변 잔해 (사이버펑크 폐허 느낌으로 개수 소량 유지)
   const debrisCount = Math.random() < 0.5 ? 2 : 1;
    if (debrisCount > 0) {
        createDebris(x, z, width + 4, debrisCount);
    }
}

// 2. 경사로 (수정: 벡터 연결 방식 + 원래 함수 이름)
function createRampToRoof(buildingMesh, bWidth, bDepth, bHeight) {
    const rampWidth = 4.0;  // 걷기 편하게 폭을 넓힘
    const rampThickness = 1.1; // 두께 (물리 뚫림 방지)

    // [호환성 수정] buildingMesh에서 좌표 추출
    const bx = buildingMesh.position.x;
    const bz = buildingMesh.position.z;

    // 1. 목표 지점 설정 (옥상 모서리와 땅바닥)
    const run = bHeight * 1.8; // 밑변 길이

    // 옥상 높이보다 반 두께만큼 내려서 타겟팅 -> 윗면이 옥상 바닥과 평평하게 만남
    const yTop = groundY + bHeight - (rampThickness / 2); 
    const yBot = groundY - (rampThickness / 2); // 땅에 살짝 박히게

    // 시작점(Bot)과 끝점(Top) 벡터 준비
    const topPos = new THREE.Vector3();
    const botPos = new THREE.Vector3();

    // 랜덤 방향 (0:앞, 1:뒤, 2:왼, 3:오)
    const side = Math.floor(Math.random() * 4);

    switch(side) {
        case 0: // Front (+Z)
            // 건물 앞쪽 벽 중앙에서 시작
            topPos.set(bx, yTop, bz + bDepth / 2);
            botPos.set(bx, yBot, bz + bDepth / 2 + run);
            break;
        case 1: // Back (-Z)
            topPos.set(bx, yTop, bz - bDepth / 2);
            botPos.set(bx, yBot, bz - bDepth / 2 - run);
            break;
        case 2: // Left (-X)
            topPos.set(bx - bWidth / 2, yTop, bz);
            botPos.set(bx - bWidth / 2 - run, yBot, bz);
            break;
        case 3: // Right (+X)
            topPos.set(bx + bWidth / 2, yTop, bz);
            botPos.set(bx + bWidth / 2 + run, yBot, bz);
            break;
    }

    // 2. 길이 및 위치 계산
    // 두 점 사이의 거리 계산 (정확한 경사로 길이)
    // +2.0은 틈새 방지용 여유분 (Overlap)
    const rampLen = topPos.distanceTo(botPos) + 2.0; 

    // 두 점의 중간 지점 (경사로의 중심 위치)
    const midPos = new THREE.Vector3().addVectors(topPos, botPos).multiplyScalar(0.5);

    // 3. 메쉬 생성
    // BoxGeometry의 Z축을 길이로 사용
    const rampGeo = new THREE.BoxGeometry(rampWidth, rampThickness + 0.1, rampLen);
    const rampMat = new THREE.MeshStandardMaterial({ 
        color: 0x555555, 
        roughness: 0.9, 
        side: THREE.DoubleSide 
    });
    
    const ramp = new THREE.Mesh(rampGeo, rampMat);

    // 4. 배치 및 회전
    ramp.position.copy(midPos);
    ramp.lookAt(topPos); // [핵심] 경사로가 옥상 지점을 바라보게 함

    // 5. 물리/그림자 설정
    ramp.castShadow = true;
    ramp.receiveShadow = true;

    ramp.updateMatrixWorld();
    ramp.geometry.computeBoundingBox();
    ramp.userData.box = new THREE.Box3().setFromObject(ramp);
    
    // 바닥/벽 등록
    ramp.userData.isFloor = true;
    colliders.floors.push(ramp);
    colliders.walls.push(ramp); 

    scene.add(ramp);
}

/* ===============================
   폐허 잔해 필드 (수정: 개수 감소)
================================ */

function createRuinsField(x, z) {
    const size = 20;
    
    // 바닥 잔해 베이스
    const baseMat = new THREE.MeshStandardMaterial({
        color: 0x444444, 
        roughness: 0.9
    });
    
    if (Math.random() > 0.6) {
        const platform = new THREE.Mesh(
            new THREE.BoxGeometry(size * 0.7, 0.5, size * 0.7),
            baseMat
        );
        platform.position.set(x, groundY + 0.25, z);
        platform.rotation.z = (Math.random() - 0.5) * 0.1;
        platform.rotation.x = (Math.random() - 0.5) * 0.1;
        
        platform.receiveShadow = true;
        platform.updateMatrixWorld();
        platform.geometry.computeBoundingBox();
        platform.userData.box = new THREE.Box3().setFromObject(platform);
        platform.userData.isFloor = true;
        
        colliders.floors.push(platform);
        scene.add(platform);
    }

    // [수정] 잔해 개수 대폭 감소 (25 -> 8개)
    // 너무 많으면 이동에 방해됨
    createDebris(x, z, size * 0.6, 4);
}

/* ===============================
   도시 생성 (맵 내부 제한)
================================ */

function updateCity(playerX, playerZ) {

    const px = Math.floor(playerX / spacing);
    const pz = Math.floor(playerZ / spacing);

    for (let dx = -viewDistance; dx <= viewDistance; dx++) {
        for (let dz = -viewDistance; dz <= viewDistance; dz++) {

            const gx = px + dx;
            const gz = pz + dz;

            const key = `${gx}_${gz}`;
            if (generatedPositions.has(key)) continue;

            const x = gx * spacing;
            const z = gz * spacing;

            if (
                Math.abs(x) > MAP_HALF - spacing ||
                Math.abs(z) > MAP_HALF - spacing
            ) {
                continue;
            }

            if (Math.random() < 0.3) {
                createRuinsField(x, z);
            } else {
                createBuilding(x, z);
            }

            generatedPositions.add(key);
        }
    }
}


        // --- 4. 컨트롤 & 카메라 로직 개선 ---
        const startScreen = document.getElementById('start-screen');
        
        // 게임 시작
       startScreen.addEventListener('click', () => { 
    state.isGameActive = true;

    player.userData.velocity.y = 0;

    updateCity(player.position.x, player.position.z);
    spawnPlayerSafely(player);
    resolvePlayerPenetration();
    updateGround(player);

    const enemy = createDetailedHumanoid(0xff4444, false);
    scene.add(enemy);
    spawnEnemySafely(enemy, player.position);

    // ✅ 여기서 즉시 제거 (핵심)
    startScreen.style.display = 'none';

    // 포인터락은 시도만
    document.body.requestPointerLock();
});


        // [핵심] 카메라 회전 (구면 좌표계: Theta-가로, Phi-세로)
        document.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement === document.body) {
                state.cam.theta -= e.movementX * 0.003; // 좌우
                state.cam.phi -= e.movementY * 0.003;   // 상하
                // 수직 각도 제한 (너무 위/아래로 못 가게)
                state.cam.phi = Math.max(0.1, Math.min(Math.PI - 0.1, state.cam.phi));
            }
        });


        
        // [핵심] 발사 (PointerDown 이벤트로 통합 - 터치패드/클릭 모두 대응)
       document.addEventListener('pointerdown', () => {
    if (state.isGameActive || isMobile) isFiring = true;
});
document.addEventListener('pointerup', () => {
    isFiring = false;
});


        window.addEventListener('keydown', e => {
    const k = e.key.toLowerCase();
    if (k === 'f') isFiring = true;
            // [추가] R키로 무기 교체
    if (e.code === 'KeyR') {
        switchWeapon();
    }
});

window.addEventListener('keyup', e => {
    const k = e.key.toLowerCase();
    if (k === 'f') isFiring = false;
});

        // [추가] 무기 교체 함수
function switchWeapon() {
    // 재장전 중이거나 공격 중이면 교체 불가
    if (state.isReloading || state.isSwinging) return;

    if (state.currentWeapon === 'rifle') {
        state.currentWeapon = 'knife';
        
        // UI 업데이트 (선택 사항)
        console.log("Switched to KNIFE");
        // 총 UI 숨기고 칼 UI 보이기 등의 로직 추가 가능
        
        // 모델 가시성 변경
        if (player.userData.knife) player.userData.knife.visible = true;
        // 총 모델이 있다면 숨김 처리: if (player.userData.rifle) player.userData.rifle.visible = false;

    } else {
        state.currentWeapon = 'rifle';
        
        console.log("Switched to RIFLE");
        
        // 모델 가시성 변경
        if (player.userData.knife) player.userData.knife.visible = false;
        // 총 모델 보이기: if (player.userData.rifle) player.userData.rifle.visible = true;
    }
}



        window.addEventListener('keydown', e => {
            const k = e.key.toLowerCase(); if (input.hasOwnProperty(k)) input[k] = true;
            if (e.code === 'Space') input.space = true;
            if (k === 'p') toggleCameraMode();
            if (e.code === 'KeyG') reloadWeapon(); // G키 누르면 재장전
        });
        window.addEventListener('keyup', e => {
            const k = e.key.toLowerCase(); if (input.hasOwnProperty(k)) input[k] = false;
            if (e.code === 'Space') input.space = false;
        });

        // 모바일 조이스틱
        const joy = { zone: document.getElementById('joystick-zone'), knob: document.getElementById('joystick-knob'), id: null, cx:0, cy:0 };
        joy.zone.addEventListener('touchstart', e => { e.preventDefault(); const t = e.changedTouches[0]; joy.id = t.identifier; const r = joy.zone.getBoundingClientRect(); joy.cx = r.left+r.width/2; joy.cy = r.top+r.height/2; updateJoy(t.clientX, t.clientY); });
        joy.zone.addEventListener('touchmove', e => { e.preventDefault(); for(let t of e.changedTouches) if(t.identifier===joy.id) updateJoy(t.clientX, t.clientY); });
        const endJoy = e => { for(let t of e.changedTouches) if(t.identifier===joy.id) { joy.id=null; joy.knob.style.transform=`translate(-50%,-50%)`; input.joyX=0; input.joyY=0; } };
        joy.zone.addEventListener('touchend', endJoy); joy.zone.addEventListener('touchcancel', endJoy);
        function updateJoy(x,y) {
            const dx = x-joy.cx, dy = y-joy.cy, d = Math.min(Math.sqrt(dx*dx+dy*dy), 60); const a = Math.atan2(dy,dx);
            joy.knob.style.transform = `translate(calc(-50% + ${Math.cos(a)*d}px), calc(-50% + ${Math.sin(a)*d}px))`;
            input.joyX = Math.cos(a)*(d/60); input.joyY = Math.sin(a)*(d/60);
        }
        document.getElementById('btn-jump').addEventListener('touchstart', e=>{e.preventDefault(); input.space=true;});
        document.getElementById('btn-jump').addEventListener('touchend', e=>{e.preventDefault(); input.space=false;});
        document.getElementById('btn-cam').addEventListener('touchstart', e=>{e.preventDefault(); toggleCameraMode();});
        document.getElementById('btn-fire').addEventListener('touchstart', e=>{
    e.preventDefault();
    isFiring = true;
});
document.getElementById('btn-fire').addEventListener('touchend', e=>{
    e.preventDefault();
    isFiring = false;
});


        function toggleCameraMode() {
            state.cameraMode = state.cameraMode === 'TPS' ? 'FPS' : 'TPS';
            player.visible = (state.cameraMode === 'TPS');
        }

        // ===== 바닥 감지 (경사 / 오르막 / 내리막 대응) =====
const groundRay = new THREE.Raycaster();
const down = new THREE.Vector3(0, -1, 0);
function updateGround(player) {
    // 1. 점프 상승 중일 때는 바닥 보정을 하지 않음
    if (player.userData.velocity.y > 0) return;

    const raycaster = new THREE.Raycaster();
    
    const rayOrigin = player.position.clone();
    rayOrigin.y += 1.5; 
    
    raycaster.set(rayOrigin, new THREE.Vector3(0, -1, 0));

    const hits = raycaster.intersectObjects(colliders.floors, false);

    if (hits.length > 0) {
        const hit = hits[0];
        if (hit.distance < 2.0) {
            player.position.y = hit.point.y; 
            player.userData.velocity.y = 0;  
            player.userData.isGrounded = true;
            return;
        }
    }

    if (player.position.y <= groundY) {
        player.position.y = groundY;
        player.userData.velocity.y = 0;
        player.userData.isGrounded = true;
    } else {
        player.userData.isGrounded = false;
    }
}


      function updateEnemyGround(enemy) {
    const footHeight = 1.6; // 적 모델의 중심(허리)에서 발바닥까지의 거리
    const rayStartOffset = 1.0; // 머리 위에서 쏘기 위한 여유분

    // 1. 레이저 시작점: 적의 위치보다 '위'에서 시작
    // (발바닥에서 쏘면 바닥에 조금만 파묻혀도 감지를 못함)
    const origin = enemy.position.clone();
    origin.y += rayStartOffset; 

    // 2. 아래로 발사
    // (전역변수 groundRay가 없다면 'new THREE.Raycaster()' 사용)
    groundRay.set(origin, new THREE.Vector3(0, -1, 0));

    // 3. 바닥 충돌 검사
    // (filter는 성능을 먹으니 colliders.floors를 그대로 사용 권장)
    const hits = groundRay.intersectObjects(colliders.floors, false);

    if (hits.length > 0) {
        const hit = hits[0];

        // 4. 거리 계산 및 스냅(Snap) 판정
        // 이상적인 거리 = rayStartOffset(1.0) + footHeight(1.6) = 2.6
        // 경사로 오차를 고려해 약간의 여유(+0.5)를 둠
        const snapThreshold = rayStartOffset + footHeight + 0.5;

        // 거리가 범위 내에 있고, 위로 점프 중이 아니라면 바닥에 붙임
        if (hit.distance <= snapThreshold && enemy.userData.velocity.y <= 0) {
            
            // [핵심] 적의 Y 위치 = 바닥 높이 + 다리 길이
            enemy.position.y = hit.point.y + footHeight;
            
            enemy.userData.velocity.y = 0;
            enemy.userData.isGrounded = true;
            return;
        }
    }

    // 바닥 감지 안됨 -> 공중 상태
    enemy.userData.isGrounded = false;

    // [안전장치] 혹시라도 맵 뚫고 떨어지면 기본 땅 위로 복구
    if (enemy.position.y < groundY + footHeight) {
        enemy.position.y = groundY + footHeight;
        enemy.userData.velocity.y = 0;
        enemy.userData.isGrounded = true;
    }
}



        // --- 5. 물리 (벽 통과 방지) ---
     function checkCollision(pos, boxSize) {
    const min = new THREE.Vector3(
        pos.x - boxSize.x/2,
        pos.y + 0.2,
        pos.z - boxSize.z/2
    );
    const max = new THREE.Vector3(
        pos.x + boxSize.x/2,
        pos.y + boxSize.y*0.5,
        pos.z + boxSize.z/2
    );

    const box = new THREE.Box3(min, max);

    for (const wall of colliders.walls) {
        if (!wall.userData.box) wall.userData.box = new THREE.Box3();
        if (wall.geometry && !wall.geometry.boundingBox) wall.geometry.computeBoundingBox();

        // ✅ 안전하게 copy
        wall.userData.box.copy(wall.geometry.boundingBox).applyMatrix4(wall.matrixWorld);

        if (box.intersectsBox(wall.userData.box)) {
            return { hit: true, box: wall.userData.box };
        }
    }

    return { hit: false };
}


        // --- 6. 게임 로직 ---
        let boss = null;
        const clock = new THREE.Clock();
        const raycaster = new THREE.Raycaster();

        function fireBullet(isEnemy = false, origin = null, direction = null) {
    const color = isEnemy ? 0xff0000 : 0xffff00;
    const bullet = new THREE.Mesh(
        new THREE.BoxGeometry(0.08, 0.08, 0.6),
        new THREE.MeshBasicMaterial({ color })
    );

    let pos = new THREE.Vector3();
    let dir = new THREE.Vector3();

    if (origin && direction) {
        // 적 발사
        pos.copy(origin);
        dir.copy(direction).normalize();
    } else {
      
// ===== 플레이어 발사 =====
pos.copy(player.position).add(new THREE.Vector3(0, 1.5, 0));

if (isMobile) {
    // 모바일: 캐릭터가 바라보는 방향으로 발사
    dir.set(0, 0, -1).applyAxisAngle(
        new THREE.Vector3(0, 1, 0),
        player.rotation.y
    );
} else {
    // PC: 크로스헤어 정중앙 (완전 수동 조준)
    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
    dir.copy(raycaster.ray.direction).normalize();
}


    }

    bullet.position.copy(pos);
    bullet.lookAt(pos.clone().add(dir));
    bullet.position.add(dir.clone().multiplyScalar(0.8));

    scene.add(bullet);

    state.bullets.push({
        mesh: bullet,
        velocity: dir.multiplyScalar(isEnemy ? 0.6 : 3.2),
        life: 90,
        isEnemy
    });
}

     /* =========================================
   [수정 완료] 보스 외형 적용 함수 (찌꺼기 제거됨)
   ========================================= */
function applyBossAppearance(boss) {
    let mainColor, glowColor;

    // 1. 보스 타입별 색상 및 빛 설정
    switch (boss.userData.type) {
        case 'tank': // 탱크: 검정 갑옷 + 붉은 빛
            mainColor = 0x1a1a1a; 
            glowColor = 0xff0000; 
            break;
        case 'rush': // 러시: 은색 갑옷 + 청록 빛
            mainColor = 0x888888;
            glowColor = 0x00ffff; 
            break;
        case 'summoner': // 서머너: 보라 갑옷 + 골드 빛
            mainColor = 0x442244;
            glowColor = 0xffd700; 
            break;
        default:
            mainColor = 0x555555;
            glowColor = 0xffffff;
    }

    // 2. 몸체 재질 적용 (코어 제외)
    boss.traverse((child) => {
        if (child.isMesh && child !== boss.userData.core) { 
            child.material = child.material.clone();
            
            // 색상 및 재질감 설정
            child.material.color.set(mainColor);
            child.material.roughness = 0.2; // 반질반질한 금속 느낌
            child.material.metalness = 0.9;
            
            // 야광 효과 (은은하게)
            child.material.emissive.set(glowColor);
            child.material.emissiveIntensity = 0.3; 
        }
    });

    // 3. 코어(가슴 구슬) 재질 적용 (강하게 발광)
    if (boss.userData.core) {
        boss.userData.core.material.color.set(glowColor);
        // 코어는 MeshBasicMaterial이라 별도 설정 없이도 밝게 보임
    }
}

// [최종] 보스 소환 (잡몹 제거 -> 5초 정적 -> 보스 등판)
function spawnBoss() {
    // [중요] 중복 실행 방지를 위해 플래그를 함수 시작하자마자 킴
    state.bossSpawned = true; 

    // 1. [1차 청소] 경고 뜨자마자 일단 적들 다 없애서 분위기 잡기
    state.enemies.forEach(enemy => scene.remove(enemy));
    state.enemies = [];
    state.gunnerCount = 0;

    // 2. 위치 계산
    const spawnDist = 30; 
    const direction = new THREE.Vector3(0, 0, -1).applyQuaternion(player.quaternion).normalize();
    const spawnPos = player.position.clone().add(direction.multiplyScalar(spawnDist));
    
    // 맵 밖 방지
    spawnPos.x = Math.max(-MAP_HALF + 20, Math.min(MAP_HALF - 20, spawnPos.x));
    spawnPos.z = Math.max(-MAP_HALF + 20, Math.min(MAP_HALF - 20, spawnPos.z));
    spawnPos.y = groundY; 

    // 3. 경고 마커 생성
    const markerGeo = new THREE.CylinderGeometry(8, 8, 100, 32); 
    const markerMat = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.3, side: THREE.DoubleSide });
    const marker = new THREE.Mesh(markerGeo, markerMat);
    marker.position.copy(spawnPos);
    marker.position.y += 50; 
    scene.add(marker);

    const bossMsg = document.getElementById('boss-msg');
    if(bossMsg) {
        bossMsg.innerText = "⚠ WARNING: OMEGA CLASS HOSTILE DETECTED ⚠";
        bossMsg.style.display = 'block';
        bossMsg.style.color = '#ff0000';
    }

    // 4. [5초 대기] 긴장감 조성
    setTimeout(() => {
        scene.remove(marker);
        if(bossMsg) bossMsg.style.display = 'none';

        // 5. [2차 청소] 5초 기다리는 동안 눈치 없이 스폰된 적이 있다면 제거
        state.enemies.forEach(enemy => scene.remove(enemy));
        state.enemies = [];
        state.gunnerCount = 0;

        // 6. 보스 생성 시작
        const bossType = Math.random() < 0.33 ? 'tank' : Math.random() < 0.5 ? 'rush' : 'summoner';
        
        boss = createDetailedHumanoid(0xffffff, true); 
        
        // 보스 스펙 설정
        const scale = 4.0; 
        boss.scale.set(scale, scale, scale); 
        boss.userData.boxSize = new THREE.Vector3(3.0, 7.5, 3.0);
        boss.userData.maxHp = 3000;
        boss.userData.hp = 3000;
        boss.userData.isGunner = false;
        boss.userData.phase = 1;
        boss.userData.lastPhase = 1;
        boss.userData.type = bossType;
        
        boss.userData.attackTimer = 0;
        boss.userData.meleeRange = 7.0; 
        boss.userData.meleeDamage = 30; 
        boss.userData.meleeCooldown = 0;
        boss.userData.isFallingEntry = true; 

        applyBossAppearance(boss);

        // 코어 장착
        const coreGeo = new THREE.SphereGeometry(0.3, 16, 16);
        const coreMat = new THREE.MeshBasicMaterial({ color: 0xffffff }); 
        const core = new THREE.Mesh(coreGeo, coreMat);
        core.position.set(0, 1.2, 0.3); 
        boss.add(core); 
        boss.userData.core = core; 
        
        applyBossAppearance(boss); // 색상 재적용

        // 하늘에서 낙하 위치 설정
        boss.position.copy(spawnPos);
        boss.position.y += 60; 

        if (!boss.userData.velocity) boss.userData.velocity = new THREE.Vector3();
        boss.userData.velocity.y = -3.0; 

        // 씬 추가
        scene.add(boss);
        // bossSpawned는 이미 위에서 true로 했으니 그대로 둠

        // UI 표시
        document.getElementById('boss-ui').style.display = 'block';
        document.getElementById('boss-hp-fill').style.width = '100%';
        document.getElementById('boss-phase').innerText = `OMEGA ${bossType.toUpperCase()} - PHASE 1`;

        console.log(`OMEGA BOSS (${bossType}) ARRIVED!`);
    }, 5000); // 5000ms = 5초
}


        
        function spawnDebris(pos, color) {
            for(let i=0; i<8; i++) {
                const m = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.2,0.2), new THREE.MeshBasicMaterial({color:color}));
                m.position.copy(pos); scene.add(m);
                state.debris.push({mesh:m, vel:new THREE.Vector3((Math.random()-0.5), Math.random(), (Math.random()-0.5)), life:40});
            }
        }



function spawnPlayerSafely(player, maxTries = 30) {
    const raycaster = new THREE.Raycaster();
    const spawnRadius = 40;
    const playerRadius = 1;

    for (let i = 0; i < maxTries; i++) {

        // 1️⃣ 랜덤 XZ
        const x = (Math.random() - 0.5) * spawnRadius;
        const z = (Math.random() - 0.5) * spawnRadius;

        // 2️⃣ 위에서 아래로 레이
        raycaster.set(
            new THREE.Vector3(x, groundY + 100, z),
            new THREE.Vector3(0, -1, 0)
        );

        const hits = raycaster.intersectObjects(colliders.floors, false);
        if (hits.length === 0) continue;

        const y = hits[0].point.y;

        // 3️⃣ 임시 위치
        const candidate = new THREE.Vector3(x, y + 2, z);

        // 4️⃣ 벽 충돌 검사 (Sphere vs Box)
        let blocked = false;
       for (const wall of colliders.walls) {
    if (!wall.userData.box) continue;

    wall.userData.box.copy(wall.geometry.boundingBox)
        .applyMatrix4(wall.matrixWorld);

    if (wall.userData.box.distanceToPoint(candidate) < playerRadius) {
        blocked = true;
        break;
    }
}


        if (blocked) continue;

        // 5️⃣ 성공
        player.position.copy(candidate);
        player.userData.velocity.y = 0;
        return true;
    }

    console.warn("안전한 스폰 위치를 찾지 못함");
    return false;
}

// [최종 완결] 적 안전 스폰 (지붕 검사 + 벽 거리두기 이중 체크)
function spawnEnemySafely(enemy) {
    const raycaster = new THREE.Raycaster();
    const downVector = new THREE.Vector3(0, -1, 0); 
    
    let attempt = 0;
    const maxAttempts = 50; 

    while (attempt < maxAttempts) {
        // 1. 랜덤 위치 선정
        const angle = Math.random() * Math.PI * 2;
        const dist = 30 + Math.random() * 40; 
        const x = player.position.x + Math.cos(angle) * dist;
        const z = player.position.z + Math.sin(angle) * dist;

        // 맵 범위 체크
        if (x < -MAP_HALF + 5 || x > MAP_HALF - 5 || z < -MAP_HALF + 5 || z > MAP_HALF - 5) {
            attempt++; continue;
        }

        // ==========================================
        // [검사 1] 수직 체크: 지붕이나 높은 곳인가?
        // ==========================================
        raycaster.set(new THREE.Vector3(x, 100, z), downVector);
        const hits = raycaster.intersectObjects([...colliders.walls, ...colliders.floors], false);

        // 아무것도 없거나(빈 땅), 닿은 곳 높이가 1.5m보다 높으면(건물/장애물 위) 실패
        let spawnY = groundY;
        if (hits.length > 0) {
            const hitY = hits[0].point.y;
            if (hitY > groundY + 1.5) { 
                attempt++; continue; // 지붕 위거나 장애물 위임 -> 다시 뽑기
            }
            spawnY = hitY;
        } else {
            // 아무것도 안 닿았으면 맨땅(groundY)으로 간주
            spawnY = groundY;
        }

        // ==========================================
        // [검사 2] 수평 체크: 주변 2.5m 내에 벽이 있는가?
        // ==========================================
        const candidatePos = new THREE.Vector3(x, spawnY, z);
        let tooCloseToWall = false;

        for (const wall of colliders.walls) {
            // 박스가 없으면 생성
            if (!wall.userData.box) {
                wall.geometry.computeBoundingBox();
                wall.userData.box = new THREE.Box3().setFromObject(wall);
            }

            // 월드 좌표 박스 준비
            const wallBox = wall.userData.box.clone();
            wallBox.applyMatrix4(wall.matrixWorld);

            // [핵심] 벽과의 거리가 2.5m 이내면 실패! (뚱뚱해도 안 낌)
            if (wallBox.distanceToPoint(candidatePos) < 2.5) {
                tooCloseToWall = true;
                break; 
            }
        }

        if (tooCloseToWall) {
            attempt++; continue; // 벽이랑 너무 가까움 -> 다시 뽑기
        }

        // ==========================================
        // [성공] 모든 검사 통과
        // ==========================================
        enemy.position.set(x, spawnY, z);
        
        if(!enemy.userData.velocity) enemy.userData.velocity = new THREE.Vector3();
        enemy.userData.velocity.y = 0;

        scene.add(enemy);
        state.enemies.push(enemy);
        return; 
    }
    
    // 실패 시 Gunner 카운트 복구
    if (enemy.userData.isGunner) {
        state.gunnerCount--;
    }
}


        
// 플레이어 벽 충돌 감지 (Raycaster 버전 - 회전된 경사로 정밀 감지)
function playerIntersectsWall(pos) {
    // 플레이어의 허리 높이 (바닥에서 약간 위)
    const rayOrigin = new THREE.Vector3(pos.x, pos.y + 1.0, pos.z);
    
    // 8방향으로 레이저를 쏴서 벽이 있는지 검사 (몸통 두께만큼)
    const directions = [
        new THREE.Vector3(1, 0, 0),  // 우
        new THREE.Vector3(-1, 0, 0), // 좌
        new THREE.Vector3(0, 0, 1),  // 앞
        new THREE.Vector3(0, 0, -1), // 뒤
        new THREE.Vector3(0.7, 0, 0.7),   // 대각선
        new THREE.Vector3(-0.7, 0, 0.7),
        new THREE.Vector3(0.7, 0, -0.7),
        new THREE.Vector3(-0.7, 0, -0.7)
    ];

    const wallRay = new THREE.Raycaster();
    const checkRadius = 1.0; // 플레이어 몸통 반지름 (충돌 범위)

    // colliders.walls에 있는 모든 물체(건물, 경사로) 검사
    for (const dir of directions) {
        wallRay.set(rayOrigin, dir);
        
        // true: 모든 자식 메쉬까지 정밀 검사
        const hits = wallRay.intersectObjects(colliders.walls, false); 
        
        if (hits.length > 0) {
            // 레이저가 닿았는데 그 거리가 내 몸통보다 가깝다면 -> 충돌!
            if (hits[0].distance < checkRadius) {
                // 단, '바닥(Floor)' 속성이 있는 경사로라면
                // 내 발보다 확실히 낮은 곳(밟을 수 있는 곳)은 벽으로 치지 않음
                // (경사로 옆구리는 벽, 윗면은 바닥으로 처리하기 위함)
                const hitObj = hits[0].object;
                const hitPointY = hits[0].point.y;
                
                // 충돌 지점이 내 발(pos.y)보다 높으면 벽임 (못 지나감)
                // 충돌 지점이 내 발보다 낮으면 밟고 지나가는 바닥임 (지나감)
                // 여유값 0.3 (계단 턱 높이)
                if (hitObj.userData.isFloor && hitPointY <= pos.y + 0.5) {
                    continue; // 밟고 지나가라
                }

                return true; // 벽에 막힘
            }
        }
    }

    return false;
}

        
        function resolvePlayerPenetration() {
    const stepUp = 0.12;
    const pushOut = 0.15;

    for (let i = 0; i < 10; i++) {
        if (!playerIntersectsWall(player.position)) return;

        // 1️⃣ 위로 밀기 (옥상/바닥 겹침)
        player.position.y += stepUp;

        // 2️⃣ XZ 랜덤 미세 이동 (벽 내부 탈출)
        const a = Math.random() * Math.PI * 2;
        player.position.x += Math.cos(a) * pushOut;
        player.position.z += Math.sin(a) * pushOut;
    }
}

        
/* =========================================
   [추가] 적(Enemy/Boss) 전용 물리 & 이동 로직
   (플레이어와 동일한 메커니즘 적용)
   ========================================= */

// 1. 적의 바닥 감지 및 중력 적용 (플레이어 updateGround + 중력 로직 통합)
function applyEnemyPhysics(enemy) {
    // 중력 적용
    if (!enemy.userData.velocity) enemy.userData.velocity = new THREE.Vector3();
    enemy.userData.velocity.y += physics.gravity;
    enemy.position.y += enemy.userData.velocity.y;

    checkEnemyCeilingCollision(enemy);

    // 바닥 감지 (Raycaster)
    // 점프 중(상승 중)일 때는 바닥 보정 스킵
    if (enemy.userData.velocity.y > 0) return;

    const raycaster = new THREE.Raycaster();
    const rayOrigin = enemy.position.clone();
    rayOrigin.y += 1.5; // 머리 위에서 시작

    raycaster.set(rayOrigin, new THREE.Vector3(0, -1, 0));

    // 바닥만 검사
    const hits = raycaster.intersectObjects(colliders.floors, false);

    if (hits.length > 0) {
        const hit = hits[0];
        // 플레이어와 동일하게 2.0 거리 내 바닥 스냅
        if (hit.distance < 2.0) {
            enemy.position.y = hit.point.y;
            enemy.userData.velocity.y = 0;
            enemy.userData.isGrounded = true;
            return;
        }
    }

    // 바닥 없으면 공중 상태
    if (enemy.position.y <= groundY) {
        enemy.position.y = groundY;
        enemy.userData.velocity.y = 0;
        enemy.userData.isGrounded = true;
    } else {
        enemy.userData.isGrounded = false;
    }
}

// 1. 적의 벽 충돌 감지 (안전장치 추가됨)
function enemyIntersectsWall(enemy) {
    const rayOrigin = new THREE.Vector3(enemy.position.x, enemy.position.y + 1.0, enemy.position.z);
    
    const directions = [
        new THREE.Vector3(1, 0, 0), new THREE.Vector3(-1, 0, 0),
        new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, -1),
        new THREE.Vector3(0.7, 0, 0.7), new THREE.Vector3(-0.7, 0, 0.7),
        new THREE.Vector3(0.7, 0, -0.7), new THREE.Vector3(-0.7, 0, -0.7)
    ];

    const wallRay = new THREE.Raycaster();
    
    // [핵심 수정] boxSize가 없으면 기본값(0.6)을 쓰도록 물음표(?)로 안전하게 처리
    const size = (enemy.userData.boxSize) 
        ? Math.max(enemy.userData.boxSize.x, enemy.userData.boxSize.z) * 0.5 
        : 0.6;

    for (const dir of directions) {
        wallRay.set(rayOrigin, dir);
        const hits = wallRay.intersectObjects(colliders.walls, false);
        
        if (hits.length > 0) {
            if (hits[0].distance < size) {
                const hitObj = hits[0].object;
                const hitPointY = hits[0].point.y;
                // 경사로(Floor)는 밟고 지나가도록 무시
                if (hitObj.userData.isFloor && hitPointY <= enemy.position.y + 0.5) {
                    continue;
                }
                return true; // 벽 막힘
            }
        }
    }
    return false;
}

// 2. 적 이동 함수 (이것도 확실하게 덮어쓰세요)
function moveEnemyLikePlayer(enemy, targetPos, speed) {
    if (!targetPos) return; // 목표가 없으면 중단 (에러 방지)

    const direction = new THREE.Vector3().subVectors(targetPos, enemy.position);
    direction.y = 0; // 높이 무시
    direction.normalize();

    const moveX = direction.x * speed;
    const moveZ = direction.z * speed;

    // X축 이동 시도
    const oldX = enemy.position.x;
    enemy.position.x += moveX;
    if (enemyIntersectsWall(enemy)) {
        enemy.position.x = oldX; // 막히면 취소
    }

    // Z축 이동 시도
    const oldZ = enemy.position.z;
    enemy.position.z += moveZ;
    if (enemyIntersectsWall(enemy)) {
        enemy.position.z = oldZ; // 막히면 취소
    }

    // 바라보기
    enemy.lookAt(targetPos.x, enemy.position.y, targetPos.z);
}
        
        // [추가] 근접 공격 함수
function meleeAttack() {
    state.isSwinging = true;

    // 1. 휘두르는 애니메이션 (간단히 팔 회전)
    // GSAP 같은 라이브러리가 없으므로 setTimeout으로 구현
    const rightArm = player.userData.rArm.root;
    const initialRot = rightArm.rotation.x;
    
    // 내려치기 동작
    rightArm.rotation.x = -Math.PI / 2; // 팔을 든다
    
    setTimeout(() => {
        rightArm.rotation.x = 0.5; // 힘껏 내리친다 (탁!)
        
        // 2. 타격 판정 (내리치는 순간)
        checkMeleeHit();
        
    }, 100);

    // 복귀
    setTimeout(() => {
        rightArm.rotation.x = initialRot; // 원위치
        state.isSwinging = false; // 공격 종료 (다시 공격 가능)
    }, 400); // 0.4초 딜레이 (공격 속도)
}

// [추가] 근접 타격 판정 (범위 공격)
function checkMeleeHit() {
    const attackRange = 2.5; // 사거리 (2.5m)
    const damage = 50;       // 데미지 (총보다 강력하게)

    // 플레이어 앞쪽 방향
    const playerDir = new THREE.Vector3(0, 0, 1).applyQuaternion(player.quaternion);

    // 모든 적 검사
    const targets = [...state.enemies];
    if (boss) targets.push(boss);

    targets.forEach(enemy => {
        const dist = player.position.distanceTo(enemy.position);

        // 1. 사거리 안에 있는가?
        if (dist <= attackRange) {
            
            // 2. 내 앞에 있는가? (뒤에 있는 적은 안 맞음)
            // 플레이어에서 적을 향하는 벡터
            const dirToEnemy = new THREE.Vector3().subVectors(enemy.position, player.position).normalize();
            // 내적(Dot Product)을 이용해 각도 계산 (0.5 이상이면 대략 전방 60도)
            const angle = playerDir.dot(dirToEnemy);

            if (angle > 0.5) { 
                // 타격 성공!
                hitEnemy(enemy, damage);
            }
        }
    });
}

// [추가] 적 피격 처리 (총/칼 공통으로 쓰면 좋음)
function hitEnemy(enemy, damage) {
    // 1. 이펙트 생성 (파편)
    spawnDebris(enemy.position, 0x00ffff); // 칼 맞으면 청록색 파편

    // 2. 일반 적 처리
    if (enemy !== boss) {
        state.score += 100;
        // 한방에 죽거나 체력 시스템 적용 가능
        // 여기서는 칼 데미지가 50이니 2방컷, 혹은 즉사 처리
        
        // 배열에서 제거
        const idx = state.enemies.indexOf(enemy);
        if (idx > -1) {
            state.enemies.splice(idx, 1);
            scene.remove(enemy);
            if (enemy.userData.isGunner) state.gunnerCount--;
        }
    } 
    // 3. 보스 처리
    else {
        boss.userData.hp -= damage;
        document.getElementById('boss-hp-fill').style.width = (boss.userData.hp / boss.userData.maxHp * 100) + '%';
        
        if (boss.userData.hp <= 0) {
            scene.remove(boss);
            state.hp = Math.min(state.hp + 30, 100);
            boss = null;
            state.bossSpawned = false;
            document.getElementById('boss-ui').style.display = 'none';
        }
    }
}


// [추가] 천장(머리 위) 충돌 감지 함수
function checkCeilingCollision(player) {
    // 위로 올라가는 중일 때만 검사 (떨어질 땐 필요 없음)
    if (player.userData.velocity.y <= 0) return;

    const raycaster = new THREE.Raycaster();
    
    // 1. 레이저 시작점: 플레이어 머리 높이 (약 1.7m)
    const rayOrigin = player.position.clone();
    rayOrigin.y += 1.7; 

    // 2. 위쪽(Up)으로 발사
    raycaster.set(rayOrigin, new THREE.Vector3(0, 1, 0));

    // 3. 벽과 바닥(경사로 포함) 모두 검사
    // 경사로 밑면도 colliders.floors에 포함되어 있으므로 감지됨
    const targetObjects = [...colliders.walls, ...colliders.floors];
    const hits = raycaster.intersectObjects(targetObjects, false);

    if (hits.length > 0) {
        // 머리 위 0.5 거리 내에 무언가 있으면
        if (hits[0].distance < 0.5) {
            // [핵심] 머리를 찧었으므로 상승 속도를 0으로 만듦 (떨어지게 됨)
            player.userData.velocity.y = 0;
            
            // (선택) 머리가 파묻히지 않게 살짝 아래로 밀어줌
            player.position.y -= 0.1;
        }
    }
}


        // [추가] 적/보스 전용 천장 충돌 감지
function checkEnemyCeilingCollision(enemy) {
    // 위로 상승 중일 때만 검사
    if (!enemy.userData.velocity || enemy.userData.velocity.y <= 0) return;

    const raycaster = new THREE.Raycaster();
    
    // 레이저 시작 높이 조절
    // 보스면 키가 크니까 4.0 위에서, 일반 적은 1.7 위에서 시작
    const heightOffset = (enemy === boss) ? 4.0 : 1.7;
    
    const rayOrigin = enemy.position.clone();
    rayOrigin.y += heightOffset; 

    // 위쪽으로 발사
    raycaster.set(rayOrigin, new THREE.Vector3(0, 1, 0));

    const targetObjects = [...colliders.walls, ...colliders.floors];
    const hits = raycaster.intersectObjects(targetObjects, false);

    if (hits.length > 0) {
        // 머리 위 0.5 거리 내에 천장/경사로가 있으면
        if (hits[0].distance < 0.5) {
            // 상승 멈춤 (머리 쿵)
            enemy.userData.velocity.y = 0;
        }
    }
}


// [추가] 플레이어 벽 충돌 감지 (발, 허리, 머리 3단 체크)
function checkPlayerWallCollision(player) {
    const raycaster = new THREE.Raycaster();
    
    // 플레이어 충돌 반경 (몸통 두께)
    const collisionRadius = 0.5; 

    // 8방향 검사 (앞, 뒤, 좌, 우, 대각선)
    const directions = [
        new THREE.Vector3(1, 0, 0), new THREE.Vector3(-1, 0, 0),
        new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, -1),
        new THREE.Vector3(0.7, 0, 0.7), new THREE.Vector3(-0.7, 0, 0.7),
        new THREE.Vector3(0.7, 0, -0.7), new THREE.Vector3(-0.7, 0, -0.7)
    ];

    // [핵심] 검사할 높이 목록 (발, 허리, 머리)
    // 플레이어 키가 약 1.8m라고 가정
    const checkHeights = [0.2, 1.0, 1.7]; 

    for (const h of checkHeights) {
        // 해당 높이로 레이저 시작점 설정
        const origin = player.position.clone();
        origin.y += h; 

        for (const dir of directions) {
            raycaster.set(origin, dir);
            
            // 벽만 검사 (바닥 제외)
            const hits = raycaster.intersectObjects(colliders.walls, false);

            if (hits.length > 0) {
                // 몸통 반경보다 가까운 벽이 있으면 충돌!
                if (hits[0].distance < collisionRadius) {
                    return true;
                }
            }
        }
    }
    return false; // 충돌 없음
}
        

        
    function animate() {
    requestAnimationFrame(animate);

    if (!state.isGameActive || state.isGameOver) return;

    // 1. 시간 & 델타
    const dt = clock.getDelta();
    const time = clock.getElapsedTime();

  // ------------------------------------------------
    // 2. 플레이어 이동 및 충돌 처리 (수정됨 - 변수 충돌 방지)
    // ------------------------------------------------
    
    // 이동 속도 설정
    const speed = (input.shift ? 0.12 : 0.05) * (isMobile ? 0.8 : 1.0);
    
    // [중요] 이동 방향 계산 (여기서 한 번만 선언)
    // 만약 위쪽에서 forward, right 오류가 또 난다면, 위쪽의 선언부를 지우세요!
    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
    const rightVector = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion); // 이름 변경 (right -> rightVector)
    
    // Y축 제거 (수평 이동만)
    forward.y = 0; forward.normalize();
    rightVector.y = 0; rightVector.normalize();

    const moveDir = new THREE.Vector3();
    
    if (input.w) moveDir.add(forward);
    if (input.s) moveDir.sub(forward);
    if (input.a) moveDir.sub(rightVector); // rightVector 사용
    if (input.d) moveDir.add(rightVector);
    
    // 모바일 조이스틱
    if (isMobile && (input.joyX !== 0 || input.joyY !== 0)) {
        const joyFwd = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
        const joyRgt = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
        joyFwd.y = 0; joyFwd.normalize();
        joyRgt.y = 0; joyRgt.normalize();
        
        moveDir.add(joyFwd.multiplyScalar(-input.joyY)); 
        moveDir.add(joyRgt.multiplyScalar(input.joyX));
    }

    // 실제 이동 적용
    if (moveDir.lengthSq() > 0) {
        moveDir.normalize().multiplyScalar(speed);

        // X축 이동 & 충돌 체크
        const oldX = player.position.x;
        player.position.x += moveDir.x;
        if (checkPlayerWallCollision(player)) {
            player.position.x = oldX; 
        }

        // Z축 이동 & 충돌 체크
        const oldZ = player.position.z;
        player.position.z += moveDir.z;
        if (checkPlayerWallCollision(player)) {
            player.position.z = oldZ; 
        }
        
        // 걷는 애니메이션
        const at = time * 15;
        player.userData.lArm.root.rotation.x = -Math.sin(at);
        player.userData.rArm.root.rotation.x = Math.sin(at);
        player.userData.lLeg.root.rotation.x = Math.sin(at);
        player.userData.rLeg.root.rotation.x = -Math.sin(at);
    } else {
        // 멈춤
        player.userData.lArm.root.rotation.x = 0;
        player.userData.rArm.root.rotation.x = 0;
        player.userData.lLeg.root.rotation.x = 0;
        player.userData.rLeg.root.rotation.x = 0;
    }

        
 // 3. 공격 시스템 (총 or 칼)
    if (isFiring) {
        
        // (A) 소총 모드일 때
        if (state.currentWeapon === 'rifle') {
            if (fireCooldown <= 0 && !state.isReloading && state.ammo > 0) {
                // ... [기존의 총 쏘는 코드 그대로 유지] ...
                // (아까 작성해드린 Raycaster 총 쏘는 코드 전체가 여기 들어갑니다)
                
                // (요약: 조준 -> Raycaster -> fireBullet -> ammo--)
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                const targetObjects = [...colliders.walls, ...colliders.floors, ...state.enemies];
                if(boss) targetObjects.push(boss);
                const hits = raycaster.intersectObjects(targetObjects, false);
                
                let targetPoint = hits.length > 0 ? hits[0].point : raycaster.ray.origin.clone().add(raycaster.ray.direction.multiplyScalar(100));
                
                let spawnPos = camera.position.clone();
                if (!isMobile) { 
                     const fwd = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                     const rgt = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                     const up = new THREE.Vector3(0, 1, 0).applyQuaternion(camera.quaternion);
                     spawnPos.add(rgt.multiplyScalar(0.4)).add(up.multiplyScalar(-0.2)).add(fwd.multiplyScalar(0.5));
                } else {
                     spawnPos.copy(player.position).add(new THREE.Vector3(0, 1.5, 0));
                }
                
                // 안전 검사
                const c2s = new THREE.Vector3().subVectors(spawnPos, camera.position);
                const sRay = new THREE.Raycaster(camera.position, c2s.normalize());
                const sHits = sRay.intersectObjects([...colliders.walls, ...colliders.floors], false);
                if ((sHits.length > 0 && sHits[0].distance < c2s.length()) || (hits.length > 0 && hits[0].distance < 2.5)) {
                    spawnPos.copy(camera.position).add(new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).multiplyScalar(0.5));
                }

                const dir = new THREE.Vector3().subVectors(targetPoint, spawnPos).normalize();
                fireBullet(false, spawnPos, dir, 2.5);

                state.ammo--;
                updateAmmoUI();
                if (state.ammo <= 0) reloadWeapon();
                fireCooldown = 15; 
            }
        } 
        // (B) 근접 무기(칼) 모드일 때
        else if (state.currentWeapon === 'knife') {
            // 쿨타임 대신 isSwinging 플래그 사용 (공격 속도 제한)
            if (!state.isSwinging) {
                meleeAttack(); // 칼 휘두르기 함수 호출
            }
        }
    }
    
    if (fireCooldown > 0) fireCooldown--;
        
    // 4. 카메라 업데이트
    const targetPos = player.position.clone().add(new THREE.Vector3(0, 1.6, 0));
    if (!isMobile) {
        const currentRadius = state.cameraMode === 'TPS' ? state.cam.radius : 0.1;
        const offsetX = currentRadius * Math.sin(state.cam.phi) * Math.sin(state.cam.theta);
        const offsetY = currentRadius * Math.cos(state.cam.phi);
        const offsetZ = currentRadius * Math.sin(state.cam.phi) * Math.cos(state.cam.theta);
        camera.position.copy(targetPos).add(new THREE.Vector3(offsetX, offsetY, offsetZ));
        camera.lookAt(targetPos);
        player.rotation.y = state.cam.theta + Math.PI;
    } else {
        camera.position.lerp(player.position.clone().add(new THREE.Vector3(0, 15, 12)), 0.1);
        camera.lookAt(player.position);
    }

    // 5. 플레이어 이동
    const fwd = new THREE.Vector3(0,0,1).applyAxisAngle(new THREE.Vector3(0,1,0), player.rotation.y);
    const right = new THREE.Vector3(-1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), player.rotation.y);
    const move = new THREE.Vector3();
    if (input.w) move.add(fwd); if (input.s) move.sub(fwd);
    if (input.d) move.add(right); if (input.a) move.sub(right);
    if (isMobile && (input.joyX || input.joyY)) {
        move.set(input.joyX,0,input.joyY);
        if(move.lengthSq()>0.01) player.rotation.y = -Math.atan2(input.joyY,input.joyX)+Math.PI/2;
    }
    move.normalize().multiplyScalar(0.25);
  // X 이동 먼저
player.position.x += move.x;
if (playerIntersectsWall(player.position)) {
    player.position.x -= move.x;
}

// Z 이동 다음
player.position.z += move.z;
if (playerIntersectsWall(player.position)) {
    player.position.z -= move.z;
}



    // 6. 점프 & 중력
    if (input.space && player.userData.isGrounded) {
        player.userData.velocity.y = physics.jump;
        player.userData.isGrounded = false;
    }
   // 1. 중력
player.userData.velocity.y += physics.gravity;

// 2. 이동
player.position.y += player.userData.velocity.y;

// 3. 즉시 바닥 보정
updateGround(player);


    // 7. 총알 업데이트
    for (let i = state.bullets.length-1; i>=0; i--) {
        const b = state.bullets[i];
        b.mesh.position.add(b.velocity);
        b.life--;
        let hit=false;

        // 벽 충돌
        if(!hit) {
            for (const wall of colliders.walls) {
                wall.userData.box.copy(wall.geometry.boundingBox).applyMatrix4(wall.matrixWorld);
                if (wall.userData.box.containsPoint(b.mesh.position)) { hit=true; break; }
            }
        }

        // 적/플레이어 충돌
        if(!hit) {
            if(b.isEnemy) {
                if(b.mesh.position.distanceTo(player.position.clone().add(new THREE.Vector3(0,1,0)))<1.0){
                    state.hp-=10; hit=true;
                    document.getElementById('damage-overlay').style.opacity=0.6;
                    setTimeout(()=>document.getElementById('damage-overlay').style.opacity=0,200);
                }
            } else {
                // 일반 적
                for(let j=state.enemies.length-1;j>=0;j--){
                    if(state.enemies[j].position.distanceTo(b.mesh.position)<1.5){
                        spawnDebris(state.enemies[j].position,0xff4444);
                        if(state.enemies[j].userData.isGunner) state.gunnerCount--;
                        scene.remove(state.enemies[j]); state.enemies.splice(j,1);
                        state.score+=100; hit=true; break;
                    }
                }
                // 보스
                if(!hit && boss && boss.position.distanceTo(b.mesh.position)<4){
                    boss.userData.hp-=20; hit=true;
                    spawnDebris(b.mesh.position,0xff0000);
                    document.getElementById('boss-hp-fill').style.width=(boss.userData.hp/boss.userData.maxHp*100)+'%';
                    if(boss.userData.hp<=0){
                        scene.remove(boss);
                        state.hp=Math.min(state.hp+20,100);
                        boss=null; state.bossSpawned=false;
                        document.getElementById('boss-ui').style.display='none';
                    }
                }
            }
        }

        if(hit || b.life<=0){ scene.remove(b.mesh); state.bullets.splice(i,1); }
    }

    // 8. 보스 페이즈 & UI
    if(boss){
        const hpRate = boss.userData.hp / boss.userData.maxHp;
        boss.userData.phase = hpRate<=0.3?3: hpRate<=0.7?2:1;

        if(boss.userData.lastPhase!==boss.userData.phase){
            boss.userData.lastPhase=boss.userData.phase;
            document.getElementById('boss-phase').innerText=`PHASE ${boss.userData.phase}`;
            const fill = document.getElementById('boss-hp-fill');
            fill.style.background = boss.userData.phase===1?'linear-gradient(90deg,#ff5555,#ff2222)':
                                   boss.userData.phase===2?'linear-gradient(90deg,#ffaa00,#ff7700)':
                                   'linear-gradient(90deg,#aa00ff,#ff00aa)';
            const msg = document.getElementById('boss-msg');
            msg.innerText=`⚠ PHASE ${boss.userData.phase} ⚠`;
            msg.style.display='block';
            setTimeout(()=>msg.style.display='none',1500);
        }
    }

        // [추가] 보스 실종 방지 안전장치
    if (boss) {
        // 1. 보스가 맵 아래로 떨어졌다면? (groundY보다 훨씬 아래)
        if (boss.position.y < groundY - 20) {
            console.warn("보스 추락 감지! 플레이어 근처로 재소환");
            // 플레이어 위쪽으로 강제 이동
            boss.position.copy(player.position).add(new THREE.Vector3(0, 20, 0));
            boss.userData.velocity.y = 0;
        }

        // 2. 보스가 너무 멀리 도망갔다면? (맵 밖)
        if (Math.abs(boss.position.x) > MAP_HALF || Math.abs(boss.position.z) > MAP_HALF) {
             console.warn("보스 탈주 감지! 맵 중앙으로 복귀");
             boss.position.set(0, 30, 0); // 맵 중앙 하늘
             boss.userData.velocity.y = 0;
        }
    }


// 9. 적/보스 스폰 & AI
    
    // [수정] 적 스폰 (최대 16마리, Gunner 최대 3마리 제한)
    if (!boss && state.enemies.length < 36 && Math.random() < 0.06) {
        
        let isGunner = false;

        // [핵심] 현재 Gunner가 3명 미만일 때만 Gunner 생성 시도 (확률 40%)
        // 3명 꽉 찼으면 무조건 일반 적(false)이 됨
        if (state.gunnerCount < 4) {
            isGunner = Math.random() < 0.6;
        }

        // Gunner면 주황색(ffaa00), 일반 적은 빨간색(ff4444)
        const color = isGunner ? 0xffaa00 : 0xff4444; 
        const e = createDetailedHumanoid(color, false);
        
        // Gunner 속성 부여
        e.userData.isGunner = isGunner;
        if (isGunner) {
            e.userData.shootCooldown = 2.0; // 생성 후 2초간 딜레이
            state.gunnerCount++; // ★ Gunner 숫자 증가
        }

        spawnEnemySafely(e); 
    }
    
    // 보스 스폰 (기존 코드 유지)
    if (state.score >= state.nextBossScore && !state.bossSpawned) {
        spawnBoss();
        state.nextBossScore += 4000;
    }

    // ★★★ [중요] 모든 적(보스 포함) 루프 시작 ★★★
    const allEnemies = [...state.enemies];
    if (boss) allEnemies.push(boss);

  allEnemies.forEach(e => { 
        
        // 1. 물리 엔진 (중력, 천장 충돌 등)
        applyEnemyPhysics(e);

        // 2. 보스 착지 이펙트
        if (e === boss) checkBossLandingEffect(e);

        // 플레이어와의 거리 계산 (미리 해둠)
        const dist = e.position.distanceTo(player.position);

        // 3. Gunner 공격 (사거리 제한 추가)
        if (e !== boss && e.userData.isGunner) {
            // [수정] 거리가 20m 이내일 때만 공격 시도 (너무 멀면 안 쏨)
            if (dist < 16.0) {
                e.userData.shootCooldown -= dt;
                
                if (e.userData.shootCooldown <= 0) {
                    // 플레이어 쪽 바라보기 (쏘기 전에)
                    e.lookAt(player.position.x, e.position.y, player.position.z);
                    
                    const dir = new THREE.Vector3().subVectors(player.position, e.position).normalize();
                    fireBullet(true, e.position.clone().add(new THREE.Vector3(0, 1.6, 0)), dir, 0.15);
                    e.userData.shootCooldown = 4.0; 
                }
            }
        }

        // 4. 보스 AI 패턴
        if (e === boss) {
            e.userData.attackTimer += dt;
            
            // (1) 근접 공격
            if (dist < e.userData.meleeRange) {
                e.userData.meleeCooldown -= dt;
                if (e.userData.meleeCooldown <= 0) {
                    state.hp -= e.userData.meleeDamage * (e.userData.phase * 0.5 + 0.5);
                    
                    const knockDir = new THREE.Vector3().subVectors(player.position, e.position).normalize().multiplyScalar(2.0);
                    knockDir.y = 0.5;
                    player.position.add(knockDir);
                    
                    const overlay = document.getElementById('damage-overlay');
                    overlay.style.opacity = 0.8; setTimeout(() => overlay.style.opacity = 0, 300);
                    shakeCamera(0.5, 300);

                    e.userData.meleeCooldown = 1.5;
                    e.userData.rArm.root.rotation.x = -2.0;
                    setTimeout(() => { e.userData.rArm.root.rotation.x = 0; }, 400);
                }
            }

            // (2) 보스 특수 스킬 (코드 유지)
            const phase = e.userData.phase;
            const type = e.userData.type;
            const attackDelay = phase === 1 ? 3.0 : phase === 2 ? 2.0 : 1.2;
            
            if (e.userData.attackTimer > attackDelay) {
                e.userData.attackTimer = 0;
                const bossHeadPos = e.position.clone().add(new THREE.Vector3(0, 6.0, 0));

                if (type === 'tank') { 
                    const count = 8 * phase; 
                    for (let i = 0; i < count; i++) {
                        const angle = (Math.PI * 2 / count) * i;
                        const dir = new THREE.Vector3(Math.sin(angle), -0.2, Math.cos(angle)).normalize();
                        fireBullet(true, bossHeadPos, dir, 0.8); 
                    }
                    shakeCamera(0.2, 100);
                }
                
                if (type === 'rush') {
                    const dir = new THREE.Vector3().subVectors(player.position, e.position).normalize();
                    const rushDist = 10 * phase; 
                    const target = e.position.clone().add(dir.multiplyScalar(rushDist));
                    moveEnemyLikePlayer(e, target, 0.5); 
                    spawnDebris(e.position, 0xffaa00, 5);
                }

                if (type === 'summoner') {
                    const count = (phase === 3 ? 2 : 1);
                    for (let i = 0; i < count; i++) {
                        if (state.enemies.length >= 8) break;
                        const minion = createDetailedHumanoid(0xffffff, false);
                        minion.position.copy(e.position).add(new THREE.Vector3((Math.random()-0.5)*8, 0, (Math.random()-0.5)*8));
                        minion.userData.isGunner = true;
                        minion.userData.shootCooldown = 1.0;
                        minion.traverse(obj => { if (obj.isMesh) obj.material.color.set(0xffd700); });
                        scene.add(minion);
                        state.enemies.push(minion);
                        state.gunnerCount++;
                    }
                }

                if (phase === 3 && Math.random() < 0.3) {
                    const teleportPos = player.position.clone().add(new THREE.Vector3((Math.random()-0.5)*10, 0, (Math.random()-0.5)*10));
                    e.position.copy(teleportPos);
                    e.position.y = groundY;
                    spawnDebris(e.position, 0xffffff, 10);
                }
            }
        } 

        // 5. 이동 및 애니메이션 (추격)
        // [수정] 멈추는 거리(stopRange)를 적 종류마다 다르게 설정
        let stopRange = 1.2; // 기본값 (일반 적: 칼질해야 하니 가까이)

        if (e === boss) {
            stopRange = e.userData.meleeRange; // 보스: 자기 사거리
        } else if (e.userData.isGunner) {
            stopRange = 10.0; // Gunner: 15m 거리 유지 (너무 붙지 않음)
        }
        
        // 정해진 사거리보다 멀면 추격
        if (dist > stopRange) {
            const speed = (e === boss) ? 0.06 : 0.1;
            moveEnemyLikePlayer(e, player.position, speed);
        } else {
            // 사거리 안이면 멈춰서 플레이어 바라봄
            e.lookAt(player.position.x, e.position.y, player.position.z);
            
            // 일반 적은 붙었을 때 때림 (Gunner는 위에서 총 쏩니다)
            if (e !== boss && !e.userData.isGunner && dist < 1.2) { 
                state.hp -= 0.5; 
                document.getElementById('damage-overlay').style.opacity = 0.3; 
            } 
        }

        // 애니메이션
        const anim = time * (e === boss ? 4 : 10);
        e.userData.lArm.root.rotation.x = -Math.sin(anim);
        e.userData.rArm.root.rotation.x = Math.sin(anim);
        e.userData.lLeg.root.rotation.x = Math.sin(anim);
        e.userData.rLeg.root.rotation.x = -Math.sin(anim);

    }); // 루프 끝
        
        
    // 10. 게임오버
    if(state.hp<=0){
        state.isGameOver=true;
        document.getElementById('game-over').style.display='flex';
        document.getElementById('final-score').innerText=state.score;
        document.exitPointerLock();
    }

    // 11. 파편(데브리)
    for(let i=state.debris.length-1;i>=0;i--){
        const d=state.debris[i];
        d.mesh.position.add(d.vel);
        d.vel.y-=0.02;
        d.life--;
        if(d.life<=0){ scene.remove(d.mesh); state.debris.splice(i,1); }
    }

    // 12. UI 업데이트 & 플레이어 애니메이션
    document.getElementById('hp-bar').innerText=`HP: ${Math.floor(state.hp)}`;
    document.getElementById('score-bar').innerText=`SCORE: ${state.score}`;
    if(input.w||input.s||input.a||input.d || (isMobile&&(input.joyX||input.joyY))){
        const at=time*15;
        player.userData.lArm.root.rotation.x=-Math.sin(at);
        player.userData.rArm.root.rotation.x=Math.sin(at);
        player.userData.lLeg.root.rotation.x=Math.sin(at);
        player.userData.rLeg.root.rotation.x=-Math.sin(at);
    }

    // 13. 렌더링
    renderer.render(scene,camera);
}

animate();

        window.addEventListener('resize', () => { camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    </script>
</body>
</html>
