<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Final Android Shooter (Original Mechanics)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; user-select: none; touch-action: none; font-family: 'Segoe UI', sans-serif; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        /* 크로스헤어 */
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            transform: translate(-50%, -50%); pointer-events: none;
        }
        #crosshair::before, #crosshair::after {
            content: ''; position: absolute; background: rgba(0, 255, 0, 1.0); box-shadow: 0 0 5px #0f0;
        }
        #crosshair::before { top: 9px; left: 0; width: 20px; height: 2px; }
        #crosshair::after { top: 0; left: 9px; width: 2px; height: 20px; }

        /* HUD */
        .stat-box {
            position: absolute; top: 20px;
            background: rgba(0, 0, 0, 0.6); color: white; padding: 10px 20px;
            border-radius: 8px; font-size: 20px; font-weight: bold;
            border: 1px solid rgba(255,255,255,0.3);
        }
        #hp-bar { left: 20px; color: #ff4444; }
        #score-bar { left: 150px; color: #44ff44; }

        /* 시작 화면 */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); display: flex; flex-direction: column;
            justify-content: center; align-items: center; color: white; z-index: 20; pointer-events: auto;
        }
        
        /* 게임 오버 */
        #game-over {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9); flex-direction: column;
            justify-content: center; align-items: center; z-index: 100; pointer-events: auto;
        }
        button { padding: 15px 40px; font-size: 24px; cursor: pointer; border-radius: 50px; border:none; font-weight: bold; background: white; }
        button:hover { background: #ff3333; color: white; }

        /* 모바일용 버튼 */
        .mobile-btn {
            display: none; position: absolute; width: 80px; height: 80px; border-radius: 50%;
            background: rgba(255,255,255,0.2); border: 2px solid white; pointer-events: auto;
            color: white; font-weight: bold; justify-content: center; align-items: center;
        }
    </style>
</head>
<body>
    <div id="ui-layer">
        <div id="crosshair"></div>
        <div class="stat-box" id="hp-bar">HP: 100</div>
        <div class="stat-box" id="score-bar">SCORE: 0</div>

        <div id="btn-fire" class="mobile-btn" style="bottom: 80px; right: 40px; background: rgba(255,0,0,0.3);">FIRE</div>
        <div id="btn-jump" class="mobile-btn" style="bottom: 80px; left: 40px;">JUMP</div>
    </div>

    <div id="start-screen">
        <h1>CLICK TO START</h1>
        <p>PC: Mouse Aim / Click Fire</p>
    </div>

    <div id="game-over">
        <h1 style="color:red; font-size:60px;">GAME OVER</h1>
        <p style="color:white; font-size:30px;">Score: <span id="final-score">0</span></p>
        <button onclick="location.reload()">RESTART</button>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- 1. 기본 설정 (맨 처음 코드 스타일 변수) ---
        let hp = 100;
        let score = 0;
        let isGameOver = false;

        const bullets = [];     // 원본 스타일: 단순 배열
        const enemies = [];     // 원본 스타일: 단순 배열
        const debrisList = [];
        const obstacles = [];
        
        // 입력 키
        const keys = { w: false, a: false, s: false, d: false, space: false };
        let cameraRotation = { x: 0, y: Math.PI }; // 시야각

        // --- 2. 씬 & 카메라 설정 ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        scene.fog = new THREE.FogExp2(0x111111, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // 조명
        const dirLight = new THREE.DirectionalLight(0xffeedd, 1.5);
        dirLight.position.set(50, 80, 50); dirLight.castShadow = true;
        dirLight.shadow.mapSize.set(2048, 2048);
        scene.add(dirLight); scene.add(new THREE.AmbientLight(0x404040));

        // 바닥
        const plane = new THREE.Mesh(new THREE.PlaneGeometry(300, 300), new THREE.MeshStandardMaterial({ color: 0x333333 }));
        plane.rotation.x = -Math.PI / 2; plane.receiveShadow = true; scene.add(plane);

        // --- 3. 캐릭터 및 객체 생성 ---
        function createHumanoid(color, isPlayer) {
            const group = new THREE.Group();
            const material = new THREE.MeshStandardMaterial({ color: color });
            
            // 간단한 박스형 인간 (가장 안정적)
            const torso = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.8, 0.3), material);
            torso.position.y = 1.2; torso.castShadow = true; group.add(torso);
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.3), material);
            head.position.y = 0.6; torso.add(head);

            // 팔다리
            const limbGeo = new THREE.BoxGeometry(0.15, 0.7, 0.15);
            const lArm = new THREE.Mesh(limbGeo, material); lArm.position.set(-0.4, 0.3, 0); torso.add(lArm);
            const rArm = new THREE.Mesh(limbGeo, material); rArm.position.set(0.4, 0.3, 0); torso.add(rArm);
            const lLeg = new THREE.Mesh(limbGeo, material); lLeg.position.set(-0.2, 0.6, 0); group.add(lLeg);
            const rLeg = new THREE.Mesh(limbGeo, material); rLeg.position.set(0.2, 0.6, 0); group.add(rLeg);

            if(isPlayer) {
                // 총 (Gun)
                const gun = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.5), new THREE.MeshBasicMaterial({ color: 0x000000 }));
                gun.position.set(0, -0.3, 0.3); 
                rArm.add(gun);
                group.userData.gunTip = gun; // 총구 위치 저장
            }

            // 충돌 박스 사이즈
            group.userData = { 
                velocity: new THREE.Vector3(), isGrounded: false, 
                boxSize: new THREE.Vector3(0.6, 1.8, 0.6),
                lLeg, rLeg, lArm, rArm 
            };
            return group;
        }

        const player = createHumanoid(0x0088ff, true);
        scene.add(player);

        // 장애물 생성 (밟을 수 있음)
        for(let i=0; i<40; i++) {
            const w = 2+Math.random()*4, h = 1+Math.random()*4, d = 2+Math.random()*4;
            const obs = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), new THREE.MeshStandardMaterial({ color: 0x666666 }));
            obs.position.set((Math.random()-0.5)*200, h/2, (Math.random()-0.5)*200);
            obs.castShadow = true; obs.receiveShadow = true;
            obs.userData.box = new THREE.Box3().setFromObject(obs);
            scene.add(obs); obstacles.push(obs);
        }

        // --- 4. 입력 처리 (Pointer Lock + Original Shooting) ---
        
        // PC: 마우스 클릭 시 시점 잠금 및 발사
        const startScreen = document.getElementById('start-screen');
        startScreen.addEventListener('click', () => document.body.requestPointerLock());
        document.addEventListener('pointerlockchange', () => {
            if (document.pointerLockElement === document.body) startScreen.style.display = 'none';
            else if(!isGameOver) startScreen.style.display = 'flex';
        });

        document.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement === document.body) {
                cameraRotation.y -= e.movementX * 0.003;
                cameraRotation.x -= e.movementY * 0.003;
                cameraRotation.x = Math.max(-1.5, Math.min(1.5, cameraRotation.x));
            }
        });

        // ★★★ 여기가 제일 중요합니다: 원본 코드의 발사 로직 복원 ★★★
        // 마우스를 누르는 순간 총알을 생성해서 bullets 배열에 넣습니다.
        document.addEventListener('mousedown', () => {
            if (document.pointerLockElement !== document.body && !isMobile) return;
            fireBullet();
        });

        // 모바일 발사 버튼
        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        if(isMobile) {
            document.querySelectorAll('.mobile-btn').forEach(b=>b.style.display='flex');
            document.getElementById('start-screen').style.display='none';
            document.getElementById('crosshair').style.display='none'; // 모바일은 자동조준이라 크로스헤어 끔
            
            document.getElementById('btn-fire').addEventListener('touchstart', (e) => { e.preventDefault(); fireBullet(); });
            document.getElementById('btn-jump').addEventListener('touchstart', (e) => { e.preventDefault(); keys.space = true; });
            document.getElementById('btn-jump').addEventListener('touchend', (e) => { e.preventDefault(); keys.space = false; });
            
            // 모바일 터치 이동 (화면 왼쪽 절반 터치 시 이동)
            window.addEventListener('touchstart', (e) => {
                if(e.touches[0].clientX < window.innerWidth/2) keys.w = true; // 간단히 전진만 구현
            });
            window.addEventListener('touchend', () => keys.w = false);
        }

        // 키보드
        window.addEventListener('keydown', e => { if(keys.hasOwnProperty(e.key.toLowerCase())) keys[e.key.toLowerCase()] = true; if(e.code==='Space') keys.space=true; });
        window.addEventListener('keyup', e => { if(keys.hasOwnProperty(e.key.toLowerCase())) keys[e.key.toLowerCase()] = false; if(e.code==='Space') keys.space=false; });

        // 총알 발사 함수 (원본 로직 기반)
        function fireBullet() {
            // 1. 총알 메쉬 생성
            const bullet = new THREE.Mesh(
                new THREE.BoxGeometry(0.1, 0.1, 0.6), 
                new THREE.MeshBasicMaterial({ color: 0xffaa00 }) // 원본 색상
            );

            // 2. 위치 설정 (총구 위치)
            const gunPos = new THREE.Vector3();
            player.userData.gunTip.getWorldPosition(gunPos);
            bullet.position.copy(gunPos);

            // 3. 방향 및 속도 설정
            // 원본은 플레이어의 회전값을 썼지만, 여기선 카메라가 보는 방향(크로스헤어)으로 쏘기 위해 계산
            let dir;
            if(isMobile) {
                // 모바일: 가장 가까운 적 자동 조준
                let target = null; let minInfo = 1000;
                enemies.forEach(e => {
                    let d = player.position.distanceTo(e.position);
                    if(d < minInfo) { minInfo = d; target = e; }
                });
                if(target) dir = new THREE.Vector3().subVectors(target.position.clone().add(new THREE.Vector3(0,1,0)), gunPos).normalize();
                else dir = new THREE.Vector3(0,0,-1).applyAxisAngle(new THREE.Vector3(0,1,0), player.rotation.y);
            } else {
                // PC: 카메라가 보는 방향
                const rotation = new THREE.Euler(cameraRotation.x, cameraRotation.y, 0);
                dir = new THREE.Vector3(0, 0, -1).applyEuler(rotation);
            }
            
            bullet.lookAt(bullet.position.clone().add(dir)); // 총알이 날아가는 방향 봄

            // 원본처럼 객체에 묶어서 배열에 push
            bullets.push({ 
                mesh: bullet, 
                velocity: dir.multiplyScalar(2.5), // 속도 2.5 (원본 수치)
                life: 100 
            });
            
            scene.add(bullet);
        }

        function spawnDebris(pos) {
            for(let i=0; i<10; i++) {
                const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.2,0.2), new THREE.MeshBasicMaterial({color: 0xff0000}));
                mesh.position.copy(pos);
                scene.add(mesh);
                debrisList.push({ mesh, vy: Math.random()*0.5, life: 50 });
            }
        }

        // --- 5. 메인 루프 (원본의 로직 복원) ---
        function checkCollision(pos, boxSize) {
            const min = new THREE.Vector3(pos.x - boxSize.x/2, pos.y, pos.z - boxSize.z/2);
            const max = new THREE.Vector3(pos.x + boxSize.x/2, pos.y + boxSize.y, pos.z + boxSize.z/2);
            const box = new THREE.Box3(min, max);
            for(const obs of obstacles) {
                if(box.intersectsBox(obs.userData.box)) return { hit: true, box: obs.userData.box };
            }
            return { hit: false };
        }

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            if(isGameOver) return;

            const time = clock.getElapsedTime();

            // 1. 플레이어 이동 (TPS 스타일)
            player.rotation.y = cameraRotation.y;
            const dir = new THREE.Vector3();
            const fwd = new THREE.Vector3(0,0,-1).applyAxisAngle(new THREE.Vector3(0,1,0), cameraRotation.y);
            const right = new THREE.Vector3(1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), cameraRotation.y);

            if(keys.w) dir.add(fwd); if(keys.s) dir.sub(fwd);
            if(keys.d) dir.add(right); if(keys.a) dir.sub(right);
            
            dir.normalize().multiplyScalar(0.25); // 이동 속도

            // X, Z 축 분리 이동 (벽 미끄러짐)
            player.position.x += dir.x;
            if(checkCollision(player.position, player.userData.boxSize).hit) player.position.x -= dir.x;
            player.position.z += dir.z;
            if(checkCollision(player.position, player.userData.boxSize).hit) player.position.z -= dir.z;

            // 점프
            if(keys.space && player.userData.isGrounded) { player.userData.velocity.y = 0.45; player.userData.isGrounded=false; }
            player.userData.velocity.y -= 0.015; // 중력
            player.position.y += player.userData.velocity.y;

            // 바닥 충돌
            const colY = checkCollision(player.position, player.userData.boxSize);
            if(colY.hit && player.userData.velocity.y < 0 && player.position.y > colY.box.min.y) {
                player.position.y = colY.box.max.y; player.userData.velocity.y = 0; player.userData.isGrounded = true;
            } else if(player.position.y < 0) {
                player.position.y = 0; player.userData.velocity.y = 0; player.userData.isGrounded = true;
            }

            // 카메라 위치 업데이트
            if(!isMobile) {
                camera.position.set(
                    player.position.x + Math.sin(cameraRotation.y) * 5,
                    player.position.y + 3 + (cameraRotation.x * 2),
                    player.position.z + Math.cos(cameraRotation.y) * 5
                );
                // 카메라는 플레이어 앞쪽을 봄 (크로스헤어 방향)
                const lookTarget = player.position.clone().add(new THREE.Vector3(0, 1.5, 0));
                // 회전값 적용된 앞쪽 지점 계산
                const forward = new THREE.Vector3(0,0,-10).applyEuler(new THREE.Euler(cameraRotation.x, cameraRotation.y, 0));
                camera.lookAt(lookTarget.add(forward));
            } else {
                camera.position.lerp(player.position.clone().add(new THREE.Vector3(0, 15, 12)), 0.1);
                camera.lookAt(player.position);
            }

            // 2. ★★★ 총알 로직 (가장 처음 코드로 복원) ★★★
            // 단순 반복문으로 총알 이동 및 거리 체크
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                
                // 이동 (b.velocity 만큼 계속 더함)
                b.mesh.position.add(b.velocity);
                b.life--;

                // 적과의 충돌 체크 (단순 거리 계산)
                let hit = false;
                for (let j = enemies.length - 1; j >= 0; j--) {
                    // 적의 위치(발바닥)에서 위로 1.0만큼 올린 곳(몸통)과의 거리
                    const enemyCenter = enemies[j].position.clone().add(new THREE.Vector3(0, 1.0, 0));
                    
                    if (b.mesh.position.distanceTo(enemyCenter) < 1.5) {
                        // 명중!
                        spawnDebris(enemies[j].position);
                        scene.remove(enemies[j]); enemies.splice(j, 1); // 적 삭제
                        scene.remove(b.mesh); bullets.splice(i, 1);   // 총알 삭제
                        score += 100; // 점수 증가
                        hit = true;
                        break;
                    }
                }

                if (hit) continue; // 맞았으면 다음 총알로

                // 장애물 충돌
                for(let obs of obstacles) {
                    if(obs.userData.box.containsPoint(b.mesh.position)) {
                        hit = true; break;
                    }
                }

                // 수명 다하거나 벽에 맞으면 삭제
                if (b.life <= 0 || hit) {
                    scene.remove(b.mesh);
                    bullets.splice(i, 1);
                }
            }

            // 3. 적 생성 및 이동
            if (enemies.length < 10 && Math.random() < 0.02) {
                const e = createHumanoid(0xff4444, false);
                const angle = Math.random() * Math.PI * 2;
                const r = 20 + Math.random() * 20;
                e.position.set(player.position.x + Math.cos(angle)*r, 10, player.position.z + Math.sin(angle)*r);
                scene.add(e); enemies.push(e);
            }

            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                e.lookAt(player.position.x, e.position.y, player.position.z);
                
                // 플레이어 쪽으로 이동
                const moveVec = new THREE.Vector3(0,0,1).applyQuaternion(e.quaternion).multiplyScalar(0.08);
                e.position.x += moveVec.x; 
                e.position.z += moveVec.z;
                
                // 적 충돌 시 게임 오버
                if(e.position.distanceTo(player.position) < 1.0) {
                    hp -= 1;
                    if(hp <= 0) {
                        isGameOver = true;
                        document.getElementById('game-over').style.display = 'flex';
                        document.getElementById('final-score').innerText = score;
                        document.exitPointerLock();
                    }
                }

                // 바닥 체크
                if(e.position.y > 0) e.position.y -= 0.1; else e.position.y = 0;

                // 걷기 애니메이션
                const anim = time * 10;
                e.userData.lLeg.rotation.x = Math.sin(anim); e.userData.rLeg.rotation.x = -Math.sin(anim);
            }

            // 4. 파편 효과
            for(let i=debrisList.length-1; i>=0; i--) {
                const d = debrisList[i];
                d.mesh.position.y += d.vy; d.vy -= 0.02; d.life--;
                if(d.life<=0) { scene.remove(d.mesh); debrisList.splice(i,1); }
            }

            // UI 업데이트
            document.getElementById('hp-bar').innerText = `HP: ${hp}`;
            document.getElementById('score-bar').innerText = `SCORE: ${score}`;

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => { camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    </script>
</body>
</html>
