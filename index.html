<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>shot game</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; user-select: none; touch-action: none; font-family: 'Segoe UI', sans-serif; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        /* ì •ë°€ í¬ë¡œìŠ¤í—¤ì–´ */
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 6px; height: 6px;
            background: #0f0; border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none;
            box-shadow: 0 0 4px #fff;
        }
        #crosshair-ring {
            position: absolute; top: 50%; left: 50%; width: 24px; height: 24px;
            border: 2px solid rgba(0, 255, 0, 0.5); border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none;
        }

        .hud-top { position: absolute; top: 20px; left: 20px; display: flex; gap: 15px; }
        .stat-box {
            background: rgba(0, 0, 0, 0.6); color: white; padding: 10px 20px;
            border-radius: 8px; font-size: 18px; font-weight: bold;
            border: 1px solid rgba(255,255,255,0.3); backdrop-filter: blur(4px);
        }
        #hp-bar { color: #ff4444; border-bottom: 3px solid #ff4444; }
        #score-bar { color: #44ff44; border-bottom: 3px solid #44ff44; }

        #boss-ui {
            display: none; position: absolute; top: 80px; left: 50%; transform: translateX(-50%);
            width: 50%; height: 25px; background: #222; border: 2px solid white; border-radius: 12px; overflow: hidden;
            box-shadow: 0 0 15px rgba(255,0,0,0.5);
        }
        #boss-hp-fill { width: 100%; height: 100%; background: linear-gradient(90deg, #ff0000, #ff5500); transition: width 0.1s; }
        #boss-msg { position: absolute; top: 55px; left: 50%; transform: translateX(-50%); color: red; font-weight: bold; display: none; text-shadow: 1px 1px 0 #000; animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0; } }

        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); display: flex; flex-direction: column;
            justify-content: center; align-items: center; color: white; z-index: 20; pointer-events: auto;
        }
        
        #game-over {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.95); flex-direction: column;
            justify-content: center; align-items: center; z-index: 100; pointer-events: auto;
        }
        button { padding: 15px 50px; font-size: 22px; cursor: pointer; border-radius: 50px; border:none; font-weight: bold; background: white; transition: 0.2s; }
        button:hover { background: #ff3333; color: white; transform: scale(1.05); }

        .mobile-controls { display: none; pointer-events: auto; }
        #joystick-zone { position: absolute; bottom: 50px; left: 40px; width: 140px; height: 140px; background: rgba(255,255,255,0.1); border-radius: 50%; border: 2px solid rgba(255,255,255,0.3); }
        #joystick-knob { position: absolute; top: 50%; left: 50%; width: 60px; height: 60px; background: rgba(255,255,255,0.8); border-radius: 50%; transform: translate(-50%, -50%); }
        .action-btn { position: absolute; width: 75px; height: 75px; border-radius: 50%; background: rgba(255,255,255,0.2); border: 2px solid white; color: white; display: flex; justify-content: center; align-items: center; font-weight: bold; font-size: 16px; user-select: none; }
        .action-btn:active { background: rgba(255,255,255,0.5); transform: scale(0.95); }
        #btn-jump { bottom: 60px; right: 40px; }
        #btn-fire { bottom: 160px; right: 100px; background: rgba(255,50,50,0.4); border-color: #ff5555; }
        #btn-cam { top: 20px; right: 20px; width: 60px; height: 60px; font-size: 14px; }

        #damage-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle, transparent 40%, red 120%); opacity: 0; pointer-events: none; transition: opacity 0.1s; z-index: 5; }
    </style>
</head>
<body>
    <div id="ui-layer">
        <div id="crosshair"></div>
        <div id="crosshair-ring"></div>
        <div class="hud-top">
            <div class="stat-box" id="hp-bar">HP: 100</div>
            <div class="stat-box" id="score-bar">SCORE: 0</div>
        </div>
        
        <div id="boss-msg">âš  WARNING: BOSS DETECTED âš </div>
        <div id="boss-ui"><div id="boss-hp-fill"></div><div id="boss-phase"
     style="position:absolute; width:100%; text-align:center;
            color:white; font-weight:bold; line-height:25px;">
    PHASE 1
</div>
</div>

        <div class="mobile-controls">
            <div id="joystick-zone"><div id="joystick-knob"></div></div>
            <div id="btn-fire" class="action-btn">FIRE</div>
            <div id="btn-jump" class="action-btn">JUMP</div>
            <div id="btn-cam" class="action-btn">CAM</div>
        </div>
    </div>

    <div id="damage-overlay"></div>

    <div id="start-screen">
        <h1 style="font-size: 40px; margin-bottom: 10px; color:#44ff44;">SYSTEM READY</h1>
        <p class="blink" style="margin-bottom: 30px;">TAP SCREEN TO START</p>
        <div style="text-align: center; color: #aaa; font-size: 14px; line-height: 1.6;">
            [PC] WASD: Move | SPACE: Jump | P: View Mode<br>
            MOUSE: Look | TAP/CLICK: Fire<br>
            (Fixed Aiming & Camera)
        </div>
    </div>

    <div id="game-over">
        <h1 style="color:red; font-size:60px; margin:0;">MISSION FAILED</h1>
        <p style="color:white; font-size:30px;">Final Score: <span id="final-score">0</span></p>
        <button onclick="location.reload()">REBOOT SYSTEM</button>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        let isFiring = false;
        let fireCooldown = 0;

        // --- 1. ì„¤ì • ë° ìƒíƒœ ---
        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        if (isMobile) {
            document.querySelector('.mobile-controls').style.display = 'block';
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('crosshair').style.display = 'none';
            document.getElementById('crosshair-ring').style.display = 'none';
        }

        const state = {
            hp: 100, score: 0, isGameOver: false, isGameActive: false,
            bossSpawned: false, nextBossScore: 5000,
            bullets: [], enemies: [], obstacles: [], debris: [],
                gunnerCount: 0, // âœ… ì´ ì¤„ ì¶”ê°€
cameraMode: 'TPS', 
            // êµ¬ë©´ ì¢Œí‘œê³„ ì‚¬ìš© (phi: ìˆ˜ì§, theta: ìˆ˜í‰)
            cam: { theta: Math.PI, phi: 1.4, radius: 4.5 } 
        };

        const input = { w: false, a: false, s: false, d: false, space: false, joyX: 0, joyY: 0 };
        const physics = { gravity: -0.018, jump: 0.45 };


        // --- 2. ì”¬ & ë Œë”ëŸ¬ ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1b2a4a);
        scene.fog = new THREE.FogExp2(0x1b2a4a, 0.004);

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 500);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

       scene.add(new THREE.HemisphereLight(0x88aaff, 0x222233, 0.8));

const arenaLight = new THREE.PointLight(0x00ffff, 1.2, 120);
arenaLight.position.set(0, 30, 0);
scene.add(arenaLight);

const warmLight = new THREE.PointLight(0xff8844, 0.6, 80);
warmLight.position.set(40, 20, 40);
scene.add(warmLight);

        const dirLight = new THREE.DirectionalLight(0xffeedd, 1.2);
        dirLight.position.set(50, 100, 50); dirLight.castShadow = true;
        dirLight.shadow.mapSize.set(2048, 2048);
        scene.add(dirLight);
        // â­ ì „ì²´ ë°ê¸° ë³´ì •ìš© í•„ë¼ì´íŠ¸
const fillLight = new THREE.AmbientLight(0x8899ff, 0.35);
scene.add(fillLight);


       

        // --- 3. ìºë¦­í„° ìƒì„± ---
        function createDetailedHumanoid(color, isPlayer, scale = 1) {
            const group = new THREE.Group();
            
            const armorMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.3, metalness: 0.5 });
            const jointMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8 });
            const glowMat = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 0.5 });

            // ìƒì²´
            const torsoGroup = new THREE.Group();
            torsoGroup.position.y = 1.1;
            
            const chest = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.4, 0.35), armorMat);
            chest.position.y = 0.2; chest.castShadow = true;
            const core = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.15, 0.05), glowMat);
            core.position.set(0, 0.2, 0.18); chest.add(core);
            torsoGroup.add(chest);

            const abs = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.3, 0.25), jointMat);
            abs.position.y = -0.15; abs.castShadow = true; torsoGroup.add(abs);

            const backpack = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.5, 0.15), armorMat);
            backpack.position.set(0, 0.1, -0.25); torsoGroup.add(backpack);
            group.add(torsoGroup);

            // ë¨¸ë¦¬
            const headGroup = new THREE.Group();
            headGroup.position.set(0, 0.5, 0);
            const headMesh = new THREE.Mesh(new THREE.BoxGeometry(0.32, 0.35, 0.35), armorMat);
            headMesh.castShadow = true; headGroup.add(headMesh);
            const visor = new THREE.Mesh(new THREE.BoxGeometry(0.33, 0.12, 0.2), glowMat);
            visor.position.set(0, 0.05, 0.1); headGroup.add(visor);
            torsoGroup.add(headGroup);

            // íŒ”ë‹¤ë¦¬
            function createLimb(x, y, isLeg) {
                const root = new THREE.Group(); root.position.set(x, y, 0);
                const joint = new THREE.Mesh(new THREE.SphereGeometry(isLeg?0.13:0.12), jointMat); root.add(joint);
                const upper = new THREE.Mesh(new THREE.BoxGeometry(0.16, isLeg?0.45:0.35, 0.16), armorMat);
                upper.position.y = isLeg?-0.25:-0.2; upper.castShadow = true; joint.add(upper);
                const midJoint = new THREE.Mesh(new THREE.SphereGeometry(0.11), jointMat);
                midJoint.position.y = isLeg?-0.25:-0.2; upper.add(midJoint);
                const lower = new THREE.Mesh(new THREE.BoxGeometry(0.15, isLeg?0.45:0.35, 0.15), armorMat);
                lower.position.y = isLeg?-0.25:-0.2; lower.castShadow = true; midJoint.add(lower);
                return { root, upper: joint, lower: midJoint };
            }

            const lArm = createLimb(-0.42, 1.45, false); const rArm = createLimb(0.42, 1.45, false);
            const lLeg = createLimb(-0.22, 0.8, true); const rLeg = createLimb(0.22, 0.8, true);
            group.add(lArm.root); group.add(rArm.root); group.add(lLeg.root); group.add(rLeg.root);

            if (isPlayer) {
                const gun = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.2, 0.6), new THREE.MeshStandardMaterial({color: 0x222222}));
                gun.position.set(0, -0.2, 0.2); rArm.lower.add(gun); group.userData.gunTip = gun;
            } else {
                const blade = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.5, 0.05), new THREE.MeshStandardMaterial({color: 0xff3333, emissive: 0x990000}));
                blade.position.set(0, -0.2, 0.2); blade.rotation.x = Math.PI/2; rArm.lower.add(blade); group.userData.gunTip = blade;
            }

           group.userData = {
    lArm, rArm, lLeg, rLeg, torso: torsoGroup,
    hp: 100,
    maxHp: 100,
    velocity: new THREE.Vector3(),
    isGrounded: false
};

// âœ… ì—¬ê¸°ì„œ ë”°ë¡œ
if (isPlayer) {
    group.userData.collider = {
        radius: 0.45,
        height: 1.7
    };
}

            group.scale.set(scale, scale, scale);
            return group;
        }

        const player = createDetailedHumanoid(0x0088ff, true);
    

        scene.add(player);
function box(w, h, d, x, y, z) {
    const geo = new THREE.BoxGeometry(w, h, d);
    const mat = new THREE.MeshStandardMaterial({ color: 0x555555 });
    const mesh = new THREE.Mesh(geo, mat);

    mesh.position.set(x, y, z);
    mesh.castShadow = true;
    mesh.receiveShadow = true;

    scene.add(mesh);

    // ë°”ë‹¥ íŒì •ìš©
    colliders.floors.push(mesh);

    return mesh;
}

       

// í”Œë ˆì´ì–´ ì´ˆê¸°í™” (velocity & grounded)
if (!player.userData.velocity) {
    player.userData.velocity = { x: 0, y: 0, z: 0 };
    player.userData.isGrounded = false;
}


/* ===============================
   ê¸°ë³¸ ì„¤ì •
================================ */

const colliders = { floors: [], walls: [] };

const groundY = 18.4;
const spacing = 25;
const viewDistance = 3;

const MAP_SIZE = 500;
const MAP_HALF = MAP_SIZE / 2;
const WALL_HEIGHT = 80;
const WALL_THICKNESS = 10;

const generatedPositions = new Set();

/* ===============================
   í™˜ê²½ (ë¯¸ë˜í˜• íí—ˆ ë¶„ìœ„ê¸°)
================================ */

scene.background = new THREE.Color(0x050508); 
scene.fog = new THREE.FogExp2(0x0a0a10, 0.0025); 

const ambientLight = new THREE.AmbientLight(0x222222, 2); 
scene.add(ambientLight);

const moonLight = new THREE.DirectionalLight(0xaaccff, 0.5);
moonLight.position.set(-50, 100, 50);
moonLight.castShadow = true;
scene.add(moonLight);

/* ===============================
   ì „ì²´ ë°”ë‹¥
================================ */

function createGround(size = 500) {
    const mat = new THREE.MeshStandardMaterial({
        color: 0x1a1a1a, 
        roughness: 0.9,
        metalness: 0.2
    });

    const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(size, size),
        mat
    );

    ground.rotation.x = -Math.PI / 2;
    ground.position.y = groundY;
    ground.receiveShadow = true;
    ground.userData.isFloor = true;

    colliders.floors.push(ground);
    scene.add(ground);
}

createGround(MAP_SIZE);

/* ===============================
   ë§µ ê²½ê³„ ë²½
================================ */

function createMapBoundaryWalls() {
    const mat = new THREE.MeshStandardMaterial({
        color: 0x0f0f0f,
        roughness: 0.4,
        metalness: 0.8,
        emissive: 0x110000,
        emissiveIntensity: 0.2
    });

    function makeWall(w, h, d, x, y, z) {
        const wall = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            mat
        );
        wall.position.set(x, y, z);
        wall.castShadow = true;
        wall.receiveShadow = true;
        wall.geometry.computeBoundingBox();
        wall.userData.box = new THREE.Box3().setFromObject(wall);

        colliders.walls.push(wall);
        scene.add(wall);
    }

    const y = groundY + WALL_HEIGHT / 2;
    makeWall(MAP_SIZE + WALL_THICKNESS * 2, WALL_HEIGHT, WALL_THICKNESS, 0, y, MAP_HALF + WALL_THICKNESS / 2);
    makeWall(MAP_SIZE + WALL_THICKNESS * 2, WALL_HEIGHT, WALL_THICKNESS, 0, y, -MAP_HALF - WALL_THICKNESS / 2);
    makeWall(WALL_THICKNESS, WALL_HEIGHT, MAP_SIZE, MAP_HALF + WALL_THICKNESS / 2, y, 0);
    makeWall(WALL_THICKNESS, WALL_HEIGHT, MAP_SIZE, -MAP_HALF - WALL_THICKNESS / 2, y, 0);
}

createMapBoundaryWalls();

/* ===============================
   ìœ í‹¸ë¦¬í‹°: ëœë¤ ì”í•´ ìƒì„±ê¸° (ê°œìˆ˜ ëŒ€í­ ê°ì†Œ)
================================ */
function createDebris(x, z, radius, count) {
    const debrisColors = [0x888888, 0x666666, 0x555555, 0x333333];
    
    for(let i=0; i<count; i++) {
        const size = 0.5 + Math.random() * 1.0; // í¬ê¸°ë„ ì•½ê°„ ì¤„ì„
        const debrisMat = new THREE.MeshStandardMaterial({
            color: debrisColors[Math.floor(Math.random() * debrisColors.length)],
            roughness: 0.9
        });
        
        const mesh = new THREE.Mesh(new THREE.BoxGeometry(size, size, size), debrisMat);
        
        const r = Math.random() * radius;
        const theta = Math.random() * Math.PI * 2;
        const dx = r * Math.cos(theta);
        const dz = r * Math.sin(theta);
        
        mesh.position.set(x + dx, groundY + size/2, z + dz);
        mesh.rotation.set(Math.random(), Math.random(), Math.random());
        
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        
        mesh.geometry.computeBoundingBox();
        mesh.userData.box = new THREE.Box3().setFromObject(mesh);
        
        // 0.6 ì´ìƒì´ë©´ ë°”ë‹¥ìœ¼ë¡œ ì¸ì •
        if(size > 0.6) {
            mesh.userData.isFloor = true;
            colliders.floors.push(mesh);
        } 
        
        scene.add(mesh);
    }
}

/* ===============================
   ê±´ë¬¼ ìƒì„±
================================ */

function createBuilding(x, z) {
    // 1. ë¯¸ë˜ì ì¸ ì¬ì§ˆ ì„¤ì • (ì–´ë‘ìš´ ë°”ë”” + ê°•ë ¬í•œ ë„¤ì˜¨)
    const bodyColor = 0x111111; // ê±°ì˜ ê²€ì€ìƒ‰ì— ê°€ê¹Œìš´ ê¸ˆì†
    const neonColors = [0x00ffff, 0xff00ff, 0x00ff00, 0xffaa00, 0xffffff]; // ì‚¬ì´ë²„í‘í¬ ë„¤ì˜¨ íŒ”ë ˆíŠ¸
    const mainNeonColor = neonColors[Math.floor(Math.random() * neonColors.length)];

    // ê±´ë¬¼ ë³¸ì²´ ì¬ì§ˆ (ì–´ë‘¡ê³  ê±°ì¹œ ê¸ˆì† ëŠë‚Œ)
    const wallMat = new THREE.MeshStandardMaterial({
        color: bodyColor,
        roughness: 0.2, // ì•½ê°„ ë°˜ë“¤ê±°ë¦¼
        metalness: 0.8  // ê¸ˆì†ì„± ê°•í™”
    });

    // ë„¤ì˜¨ ì¬ì§ˆ (ê°•í•˜ê²Œ ë¹›ë‚¨)
    const neonMat = new THREE.MeshStandardMaterial({
        color: mainNeonColor,
        emissive: mainNeonColor,
        emissiveIntensity: 2.0, // ê°•í•œ ë°œê´‘
        roughness: 0.0,
        metalness: 0.0
    });

    const floorMat = new THREE.MeshStandardMaterial({
        color: 0x050505,
        roughness: 0.9
    });

    // 2. í¬ê¸° ëœë¤ ì„¤ì •
    const width  = 10 + Math.random() * 6;
    const depth  = 10 + Math.random() * 6;
    const height = 15 + Math.random() * 25; // ë” ë†’ê³  ì›…ì¥í•˜ê²Œ

    // 3. ê±´ë¬¼ ë³¸ì²´ (ë¬¼ë¦¬ ì¶©ëŒì²´ ì—­í• )
    const building = new THREE.Mesh(
        new THREE.BoxGeometry(width, height, depth),
        wallMat
    );

    // ìœ„ì¹˜ ì„¤ì •
    building.position.set(x, groundY + height / 2, z);
    building.castShadow = true;
    building.receiveShadow = true;

    // --- [ë””í…Œì¼ ì¶”ê°€] ë¯¸ë˜ ë„ì‹œ ëŠë‚Œ ë‚´ê¸° ---
    
    // ìŠ¤íƒ€ì¼ ëœë¤ ì„ íƒ (0: ìˆ˜ì§ ìŠ¤íŠ¸ë¼ì´í”„, 1: ì½”ë„ˆ ê¸°ë‘¥, 2: ëœë¤ ì°½ë¬¸)
    const style = Math.floor(Math.random() * 3);

    if (style === 0) {
        // ìŠ¤íƒ€ì¼ 1: ìˆ˜ì§ ë„¤ì˜¨ ìŠ¤íŠ¸ë¼ì´í”„ (Tron ìŠ¤íƒ€ì¼)
        const stripCount = 4;
        const stripGeo = new THREE.BoxGeometry(0.5, height, 0.5); // ì–‡ì€ ê¸°ë‘¥
        
        // ì•, ë’¤, ì¢Œ, ìš°ì— ë„¤ì˜¨ ê¸°ë‘¥ ë°•ê¸°
        for (let i = 0; i < stripCount; i++) {
            const strip = new THREE.Mesh(stripGeo, neonMat);
            
            // ê±´ë¬¼ í‘œë©´ì— ì ˆë°˜ì¯¤ ë¬»íˆê²Œ ë°°ì¹˜
            if (i === 0) strip.position.set(0, 0, depth/2); // ì•
            if (i === 1) strip.position.set(0, 0, -depth/2); // ë’¤
            if (i === 2) strip.position.set(width/2, 0, 0); // ìš°
            if (i === 3) strip.position.set(-width/2, 0, 0); // ì¢Œ
            
            building.add(strip); // ê±´ë¬¼ì˜ ìì‹ìœ¼ë¡œ ì¶”ê°€ (ê°™ì´ ì›€ì§ì„)
        }
    } 
    else if (style === 1) {
        // ìŠ¤íƒ€ì¼ 2: ì½”ë„ˆ ê°€ë“œ (ê±´ë¬¼ ëª¨ì„œë¦¬ì— ë„¤ì˜¨)
        const cornerGeo = new THREE.BoxGeometry(0.8, height, 0.8);
        const positions = [
            [width/2, depth/2], [width/2, -depth/2],
            [-width/2, depth/2], [-width/2, -depth/2]
        ];
        
        positions.forEach(pos => {
            const pillar = new THREE.Mesh(cornerGeo, neonMat);
            pillar.position.set(pos[0], 0, pos[1]);
            building.add(pillar);
        });
    } 
    else {
        // ìŠ¤íƒ€ì¼ 3: ë°ì´í„° ì„œë²„ ìŠ¤íƒ€ì¼ (ëœë¤í•œ ë„¤ì˜¨ ì ë“¤)
        const windowSize = 0.5;
        const windowGeo = new THREE.BoxGeometry(windowSize, windowSize, 0.2);
        
        for (let i = 0; i < 10; i++) { // ë©´ë§ˆë‹¤ 10ê°œ ì •ë„
            const win = new THREE.Mesh(windowGeo, neonMat);
            
            // ëœë¤ ë©´ ì„ íƒ (ì•/ë’¤/ì¢Œ/ìš°)
            const face = Math.floor(Math.random() * 4);
            const wX = (Math.random() - 0.5) * width * 0.8;
            const wY = (Math.random() - 0.5) * height * 0.8;
            const wZ = (Math.random() - 0.5) * depth * 0.8;

            if (face === 0) win.position.set(wX, wY, depth/2);
            else if (face === 1) win.position.set(wX, wY, -depth/2);
            else if (face === 2) win.position.set(width/2, wY, wZ);
            else win.position.set(-width/2, wY, wZ);

            if (face > 1) win.rotation.y = Math.PI / 2;
            
            building.add(win);
        }
    }

    // ------------------------------------

    // ë¬¼ë¦¬ ì¶©ëŒ ë°•ìŠ¤ ë“±ë¡ (ë³¸ì²´ ê¸°ì¤€)
    building.updateMatrixWorld();
    building.geometry.computeBoundingBox();
    building.userData.box = new THREE.Box3().setFromObject(building);
    colliders.walls.push(building);
    scene.add(building);

    // 4. ì˜¥ìƒ (Roof) - ê±·ê¸°ìš©
    const roofThickness = 0.5;
    const roof = new THREE.Mesh(
        new THREE.BoxGeometry(width, roofThickness, depth),
        floorMat
    );
    roof.position.set(x, groundY + height, z);
    roof.receiveShadow = true;
    roof.userData.isFloor = true;
    
    // ì˜¥ìƒ í…Œë‘ë¦¬ì— ë„¤ì˜¨ ë‘ë¥´ê¸° (ë‚™ì‚¬ ë°©ì§€ ê°€ì´ë“œë¼ì¸ ì—­í• ë„ í•¨)
    const roofBorderGeo = new THREE.BoxGeometry(width + 0.2, 0.2, depth + 0.2);
    const roofBorder = new THREE.Mesh(roofBorderGeo, neonMat);
    roofBorder.position.y = 0; // roof ê¸°ì¤€ ë¡œì»¬ 0
    roof.add(roofBorder);

    roof.updateMatrixWorld();
    roof.geometry.computeBoundingBox();
    roof.userData.box = new THREE.Box3().setFromObject(roof);
    colliders.floors.push(roof);
    scene.add(roof);

    // 5. ê²½ì‚¬ë¡œ ì—°ê²° (ê¸°ì¡´ ë¡œì§ ìœ ì§€)
    createRampToRoof(building, width, depth, height);

    // 6. ì£¼ë³€ ì”í•´ (ì‚¬ì´ë²„í‘í¬ íí—ˆ ëŠë‚Œìœ¼ë¡œ ê°œìˆ˜ ì†ŒëŸ‰ ìœ ì§€)
    createDebris(x, z, width + 4, Math.floor(Math.random() * 2) + 1);
}

// 2. ê²½ì‚¬ë¡œ (ìˆ˜ì •: ë²¡í„° ì—°ê²° ë°©ì‹ + ì›ë˜ í•¨ìˆ˜ ì´ë¦„)
function createRampToRoof(buildingMesh, bWidth, bDepth, bHeight) {
    const rampWidth = 4.0;  // ê±·ê¸° í¸í•˜ê²Œ í­ì„ ë„“í˜
    const rampThickness = 2.0; // ë‘ê»˜ (ë¬¼ë¦¬ ëš«ë¦¼ ë°©ì§€)

    // [í˜¸í™˜ì„± ìˆ˜ì •] buildingMeshì—ì„œ ì¢Œí‘œ ì¶”ì¶œ
    const bx = buildingMesh.position.x;
    const bz = buildingMesh.position.z;

    // 1. ëª©í‘œ ì§€ì  ì„¤ì • (ì˜¥ìƒ ëª¨ì„œë¦¬ì™€ ë•…ë°”ë‹¥)
    const run = bHeight * 1.8; // ë°‘ë³€ ê¸¸ì´

    // ì˜¥ìƒ ë†’ì´ë³´ë‹¤ ë°˜ ë‘ê»˜ë§Œí¼ ë‚´ë ¤ì„œ íƒ€ê²ŸíŒ… -> ìœ—ë©´ì´ ì˜¥ìƒ ë°”ë‹¥ê³¼ í‰í‰í•˜ê²Œ ë§Œë‚¨
    const yTop = groundY + bHeight - (rampThickness / 2); 
    const yBot = groundY - (rampThickness / 2); // ë•…ì— ì‚´ì§ ë°•íˆê²Œ

    // ì‹œì‘ì (Bot)ê³¼ ëì (Top) ë²¡í„° ì¤€ë¹„
    const topPos = new THREE.Vector3();
    const botPos = new THREE.Vector3();

    // ëœë¤ ë°©í–¥ (0:ì•, 1:ë’¤, 2:ì™¼, 3:ì˜¤)
    const side = Math.floor(Math.random() * 4);

    switch(side) {
        case 0: // Front (+Z)
            // ê±´ë¬¼ ì•ìª½ ë²½ ì¤‘ì•™ì—ì„œ ì‹œì‘
            topPos.set(bx, yTop, bz + bDepth / 2);
            botPos.set(bx, yBot, bz + bDepth / 2 + run);
            break;
        case 1: // Back (-Z)
            topPos.set(bx, yTop, bz - bDepth / 2);
            botPos.set(bx, yBot, bz - bDepth / 2 - run);
            break;
        case 2: // Left (-X)
            topPos.set(bx - bWidth / 2, yTop, bz);
            botPos.set(bx - bWidth / 2 - run, yBot, bz);
            break;
        case 3: // Right (+X)
            topPos.set(bx + bWidth / 2, yTop, bz);
            botPos.set(bx + bWidth / 2 + run, yBot, bz);
            break;
    }

    // 2. ê¸¸ì´ ë° ìœ„ì¹˜ ê³„ì‚°
    // ë‘ ì  ì‚¬ì´ì˜ ê±°ë¦¬ ê³„ì‚° (ì •í™•í•œ ê²½ì‚¬ë¡œ ê¸¸ì´)
    // +2.0ì€ í‹ˆìƒˆ ë°©ì§€ìš© ì—¬ìœ ë¶„ (Overlap)
    const rampLen = topPos.distanceTo(botPos) + 2.0; 

    // ë‘ ì ì˜ ì¤‘ê°„ ì§€ì  (ê²½ì‚¬ë¡œì˜ ì¤‘ì‹¬ ìœ„ì¹˜)
    const midPos = new THREE.Vector3().addVectors(topPos, botPos).multiplyScalar(0.5);

    // 3. ë©”ì‰¬ ìƒì„±
    // BoxGeometryì˜ Zì¶•ì„ ê¸¸ì´ë¡œ ì‚¬ìš©
    const rampGeo = new THREE.BoxGeometry(rampWidth, rampThickness, rampLen);
    const rampMat = new THREE.MeshStandardMaterial({ 
        color: 0x555555, 
        roughness: 0.9, 
        side: THREE.DoubleSide 
    });
    
    const ramp = new THREE.Mesh(rampGeo, rampMat);

    // 4. ë°°ì¹˜ ë° íšŒì „
    ramp.position.copy(midPos);
    ramp.lookAt(topPos); // [í•µì‹¬] ê²½ì‚¬ë¡œê°€ ì˜¥ìƒ ì§€ì ì„ ë°”ë¼ë³´ê²Œ í•¨

    // 5. ë¬¼ë¦¬/ê·¸ë¦¼ì ì„¤ì •
    ramp.castShadow = true;
    ramp.receiveShadow = true;

    ramp.updateMatrixWorld();
    ramp.geometry.computeBoundingBox();
    ramp.userData.box = new THREE.Box3().setFromObject(ramp);
    
    // ë°”ë‹¥/ë²½ ë“±ë¡
    ramp.userData.isFloor = true;
    colliders.floors.push(ramp);
    colliders.walls.push(ramp); 

    scene.add(ramp);
}

/* ===============================
   íí—ˆ ì”í•´ í•„ë“œ (ìˆ˜ì •: ê°œìˆ˜ ê°ì†Œ)
================================ */

function createRuinsField(x, z) {
    const size = 20;
    
    // ë°”ë‹¥ ì”í•´ ë² ì´ìŠ¤
    const baseMat = new THREE.MeshStandardMaterial({
        color: 0x444444, 
        roughness: 0.9
    });
    
    if (Math.random() > 0.4) {
        const platform = new THREE.Mesh(
            new THREE.BoxGeometry(size * 0.7, 0.5, size * 0.7),
            baseMat
        );
        platform.position.set(x, groundY + 0.25, z);
        platform.rotation.z = (Math.random() - 0.5) * 0.1;
        platform.rotation.x = (Math.random() - 0.5) * 0.1;
        
        platform.receiveShadow = true;
        platform.updateMatrixWorld();
        platform.geometry.computeBoundingBox();
        platform.userData.box = new THREE.Box3().setFromObject(platform);
        platform.userData.isFloor = true;
        
        colliders.floors.push(platform);
        scene.add(platform);
    }

    // [ìˆ˜ì •] ì”í•´ ê°œìˆ˜ ëŒ€í­ ê°ì†Œ (25 -> 8ê°œ)
    // ë„ˆë¬´ ë§ìœ¼ë©´ ì´ë™ì— ë°©í•´ë¨
    createDebris(x, z, size * 0.6, 8);
}

/* ===============================
   ë„ì‹œ ìƒì„± (ë§µ ë‚´ë¶€ ì œí•œ)
================================ */

function updateCity(playerX, playerZ) {

    const px = Math.floor(playerX / spacing);
    const pz = Math.floor(playerZ / spacing);

    for (let dx = -viewDistance; dx <= viewDistance; dx++) {
        for (let dz = -viewDistance; dz <= viewDistance; dz++) {

            const gx = px + dx;
            const gz = pz + dz;

            const key = `${gx}_${gz}`;
            if (generatedPositions.has(key)) continue;

            const x = gx * spacing;
            const z = gz * spacing;

            if (
                Math.abs(x) > MAP_HALF - spacing ||
                Math.abs(z) > MAP_HALF - spacing
            ) {
                continue;
            }

            if (Math.random() < 0.3) {
                createRuinsField(x, z);
            } else {
                createBuilding(x, z);
            }

            generatedPositions.add(key);
        }
    }
}


        // --- 4. ì»¨íŠ¸ë¡¤ & ì¹´ë©”ë¼ ë¡œì§ ê°œì„  ---
        const startScreen = document.getElementById('start-screen');
        
        // ê²Œì„ ì‹œì‘
       startScreen.addEventListener('click', () => { 
    state.isGameActive = true;

    player.userData.velocity.y = 0;

    updateCity(player.position.x, player.position.z);
    spawnPlayerSafely(player);
    resolvePlayerPenetration();
    updateGround(player);

    const enemy = createDetailedHumanoid(0xff4444, false);
    scene.add(enemy);
    spawnEnemySafely(enemy, player.position);

    // âœ… ì—¬ê¸°ì„œ ì¦‰ì‹œ ì œê±° (í•µì‹¬)
    startScreen.style.display = 'none';

    // í¬ì¸í„°ë½ì€ ì‹œë„ë§Œ
    document.body.requestPointerLock();
});


        // [í•µì‹¬] ì¹´ë©”ë¼ íšŒì „ (êµ¬ë©´ ì¢Œí‘œê³„: Theta-ê°€ë¡œ, Phi-ì„¸ë¡œ)
        document.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement === document.body) {
                state.cam.theta -= e.movementX * 0.003; // ì¢Œìš°
                state.cam.phi -= e.movementY * 0.003;   // ìƒí•˜
                // ìˆ˜ì§ ê°ë„ ì œí•œ (ë„ˆë¬´ ìœ„/ì•„ë˜ë¡œ ëª» ê°€ê²Œ)
                state.cam.phi = Math.max(0.1, Math.min(Math.PI - 0.1, state.cam.phi));
            }
        });


        
        // [í•µì‹¬] ë°œì‚¬ (PointerDown ì´ë²¤íŠ¸ë¡œ í†µí•© - í„°ì¹˜íŒ¨ë“œ/í´ë¦­ ëª¨ë‘ ëŒ€ì‘)
       document.addEventListener('pointerdown', () => {
    if (state.isGameActive || isMobile) isFiring = true;
});
document.addEventListener('pointerup', () => {
    isFiring = false;
});


        window.addEventListener('keydown', e => {
    const k = e.key.toLowerCase();
    if (k === 'f') isFiring = true;
});

window.addEventListener('keyup', e => {
    const k = e.key.toLowerCase();
    if (k === 'f') isFiring = false;
});



        window.addEventListener('keydown', e => {
            const k = e.key.toLowerCase(); if (input.hasOwnProperty(k)) input[k] = true;
            if (e.code === 'Space') input.space = true;
            if (k === 'p') toggleCameraMode();
        });
        window.addEventListener('keyup', e => {
            const k = e.key.toLowerCase(); if (input.hasOwnProperty(k)) input[k] = false;
            if (e.code === 'Space') input.space = false;
        });

        // ëª¨ë°”ì¼ ì¡°ì´ìŠ¤í‹±
        const joy = { zone: document.getElementById('joystick-zone'), knob: document.getElementById('joystick-knob'), id: null, cx:0, cy:0 };
        joy.zone.addEventListener('touchstart', e => { e.preventDefault(); const t = e.changedTouches[0]; joy.id = t.identifier; const r = joy.zone.getBoundingClientRect(); joy.cx = r.left+r.width/2; joy.cy = r.top+r.height/2; updateJoy(t.clientX, t.clientY); });
        joy.zone.addEventListener('touchmove', e => { e.preventDefault(); for(let t of e.changedTouches) if(t.identifier===joy.id) updateJoy(t.clientX, t.clientY); });
        const endJoy = e => { for(let t of e.changedTouches) if(t.identifier===joy.id) { joy.id=null; joy.knob.style.transform=`translate(-50%,-50%)`; input.joyX=0; input.joyY=0; } };
        joy.zone.addEventListener('touchend', endJoy); joy.zone.addEventListener('touchcancel', endJoy);
        function updateJoy(x,y) {
            const dx = x-joy.cx, dy = y-joy.cy, d = Math.min(Math.sqrt(dx*dx+dy*dy), 60); const a = Math.atan2(dy,dx);
            joy.knob.style.transform = `translate(calc(-50% + ${Math.cos(a)*d}px), calc(-50% + ${Math.sin(a)*d}px))`;
            input.joyX = Math.cos(a)*(d/60); input.joyY = Math.sin(a)*(d/60);
        }
        document.getElementById('btn-jump').addEventListener('touchstart', e=>{e.preventDefault(); input.space=true;});
        document.getElementById('btn-jump').addEventListener('touchend', e=>{e.preventDefault(); input.space=false;});
        document.getElementById('btn-cam').addEventListener('touchstart', e=>{e.preventDefault(); toggleCameraMode();});
        document.getElementById('btn-fire').addEventListener('touchstart', e=>{
    e.preventDefault();
    isFiring = true;
});
document.getElementById('btn-fire').addEventListener('touchend', e=>{
    e.preventDefault();
    isFiring = false;
});


        function toggleCameraMode() {
            state.cameraMode = state.cameraMode === 'TPS' ? 'FPS' : 'TPS';
            player.visible = (state.cameraMode === 'TPS');
        }

        // ===== ë°”ë‹¥ ê°ì§€ (ê²½ì‚¬ / ì˜¤ë¥´ë§‰ / ë‚´ë¦¬ë§‰ ëŒ€ì‘) =====
const groundRay = new THREE.Raycaster();
const down = new THREE.Vector3(0, -1, 0);
function updateGround(player) {
    // 1. ì í”„ ìƒìŠ¹ ì¤‘ì¼ ë•ŒëŠ” ë°”ë‹¥ ë³´ì •ì„ í•˜ì§€ ì•ŠìŒ
    if (player.userData.velocity.y > 0) return;

    const raycaster = new THREE.Raycaster();
    
    const rayOrigin = player.position.clone();
    rayOrigin.y += 1.5; 
    
    raycaster.set(rayOrigin, new THREE.Vector3(0, -1, 0));

    const hits = raycaster.intersectObjects(colliders.floors, false);

    if (hits.length > 0) {
        const hit = hits[0];
        if (hit.distance < 2.0) {
            player.position.y = hit.point.y; 
            player.userData.velocity.y = 0;  
            player.userData.isGrounded = true;
            return;
        }
    }

    if (player.position.y <= groundY) {
        player.position.y = groundY;
        player.userData.velocity.y = 0;
        player.userData.isGrounded = true;
    } else {
        player.userData.isGrounded = false;
    }
}


      function updateEnemyGround(enemy) {
    const footHeight = 1.6; // ì  ëª¨ë¸ì˜ ì¤‘ì‹¬(í—ˆë¦¬)ì—ì„œ ë°œë°”ë‹¥ê¹Œì§€ì˜ ê±°ë¦¬
    const rayStartOffset = 1.0; // ë¨¸ë¦¬ ìœ„ì—ì„œ ì˜ê¸° ìœ„í•œ ì—¬ìœ ë¶„

    // 1. ë ˆì´ì € ì‹œì‘ì : ì ì˜ ìœ„ì¹˜ë³´ë‹¤ 'ìœ„'ì—ì„œ ì‹œì‘
    // (ë°œë°”ë‹¥ì—ì„œ ì˜ë©´ ë°”ë‹¥ì— ì¡°ê¸ˆë§Œ íŒŒë¬»í˜€ë„ ê°ì§€ë¥¼ ëª»í•¨)
    const origin = enemy.position.clone();
    origin.y += rayStartOffset; 

    // 2. ì•„ë˜ë¡œ ë°œì‚¬
    // (ì „ì—­ë³€ìˆ˜ groundRayê°€ ì—†ë‹¤ë©´ 'new THREE.Raycaster()' ì‚¬ìš©)
    groundRay.set(origin, new THREE.Vector3(0, -1, 0));

    // 3. ë°”ë‹¥ ì¶©ëŒ ê²€ì‚¬
    // (filterëŠ” ì„±ëŠ¥ì„ ë¨¹ìœ¼ë‹ˆ colliders.floorsë¥¼ ê·¸ëŒ€ë¡œ ì‚¬ìš© ê¶Œì¥)
    const hits = groundRay.intersectObjects(colliders.floors, false);

    if (hits.length > 0) {
        const hit = hits[0];

        // 4. ê±°ë¦¬ ê³„ì‚° ë° ìŠ¤ëƒ…(Snap) íŒì •
        // ì´ìƒì ì¸ ê±°ë¦¬ = rayStartOffset(1.0) + footHeight(1.6) = 2.6
        // ê²½ì‚¬ë¡œ ì˜¤ì°¨ë¥¼ ê³ ë ¤í•´ ì•½ê°„ì˜ ì—¬ìœ (+0.5)ë¥¼ ë‘ 
        const snapThreshold = rayStartOffset + footHeight + 0.5;

        // ê±°ë¦¬ê°€ ë²”ìœ„ ë‚´ì— ìˆê³ , ìœ„ë¡œ ì í”„ ì¤‘ì´ ì•„ë‹ˆë¼ë©´ ë°”ë‹¥ì— ë¶™ì„
        if (hit.distance <= snapThreshold && enemy.userData.velocity.y <= 0) {
            
            // [í•µì‹¬] ì ì˜ Y ìœ„ì¹˜ = ë°”ë‹¥ ë†’ì´ + ë‹¤ë¦¬ ê¸¸ì´
            enemy.position.y = hit.point.y + footHeight;
            
            enemy.userData.velocity.y = 0;
            enemy.userData.isGrounded = true;
            return;
        }
    }

    // ë°”ë‹¥ ê°ì§€ ì•ˆë¨ -> ê³µì¤‘ ìƒíƒœ
    enemy.userData.isGrounded = false;

    // [ì•ˆì „ì¥ì¹˜] í˜¹ì‹œë¼ë„ ë§µ ëš«ê³  ë–¨ì–´ì§€ë©´ ê¸°ë³¸ ë•… ìœ„ë¡œ ë³µêµ¬
    if (enemy.position.y < groundY + footHeight) {
        enemy.position.y = groundY + footHeight;
        enemy.userData.velocity.y = 0;
        enemy.userData.isGrounded = true;
    }
}



        // --- 5. ë¬¼ë¦¬ (ë²½ í†µê³¼ ë°©ì§€) ---
     function checkCollision(pos, boxSize) {
    const min = new THREE.Vector3(
        pos.x - boxSize.x/2,
        pos.y + 0.2,
        pos.z - boxSize.z/2
    );
    const max = new THREE.Vector3(
        pos.x + boxSize.x/2,
        pos.y + boxSize.y*0.5,
        pos.z + boxSize.z/2
    );

    const box = new THREE.Box3(min, max);

    for (const wall of colliders.walls) {
        if (!wall.userData.box) wall.userData.box = new THREE.Box3();
        if (wall.geometry && !wall.geometry.boundingBox) wall.geometry.computeBoundingBox();

        // âœ… ì•ˆì „í•˜ê²Œ copy
        wall.userData.box.copy(wall.geometry.boundingBox).applyMatrix4(wall.matrixWorld);

        if (box.intersectsBox(wall.userData.box)) {
            return { hit: true, box: wall.userData.box };
        }
    }

    return { hit: false };
}


        // --- 6. ê²Œì„ ë¡œì§ ---
        let boss = null;
        const clock = new THREE.Clock();
        const raycaster = new THREE.Raycaster();

        function fireBullet(isEnemy = false, origin = null, direction = null) {
    const color = isEnemy ? 0xff0000 : 0xffff00;
    const bullet = new THREE.Mesh(
        new THREE.BoxGeometry(0.08, 0.08, 0.6),
        new THREE.MeshBasicMaterial({ color })
    );

    let pos = new THREE.Vector3();
    let dir = new THREE.Vector3();

    if (origin && direction) {
        // ì  ë°œì‚¬
        pos.copy(origin);
        dir.copy(direction).normalize();
    } else {
      
// ===== í”Œë ˆì´ì–´ ë°œì‚¬ =====
pos.copy(player.position).add(new THREE.Vector3(0, 1.5, 0));

if (isMobile) {
    // ëª¨ë°”ì¼: ìºë¦­í„°ê°€ ë°”ë¼ë³´ëŠ” ë°©í–¥ìœ¼ë¡œ ë°œì‚¬
    dir.set(0, 0, -1).applyAxisAngle(
        new THREE.Vector3(0, 1, 0),
        player.rotation.y
    );
} else {
    // PC: í¬ë¡œìŠ¤í—¤ì–´ ì •ì¤‘ì•™ (ì™„ì „ ìˆ˜ë™ ì¡°ì¤€)
    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
    dir.copy(raycaster.ray.direction).normalize();
}


    }

    bullet.position.copy(pos);
    bullet.lookAt(pos.clone().add(dir));
    bullet.position.add(dir.clone().multiplyScalar(0.8));

    scene.add(bullet);

    state.bullets.push({
        mesh: bullet,
        velocity: dir.multiplyScalar(isEnemy ? 0.6 : 3.2),
        life: 90,
        isEnemy
    });
}

        function applyBossAppearance(boss) {
    let color;

    switch (boss.userData.type) {
        case 'tank':      // ğŸ”´ ë¬´ê±°ìš´ ë³´ìŠ¤
            color = 0xaa2222;
            break;
        case 'rush':      // âš¡ ë¹ ë¥¸ ë³´ìŠ¤
            color = 0x22aaff;
            break;
        case 'summoner':  // ğŸ§  ì†Œí™˜í˜•
            color = 0xaa22ff;
            break;
        default:
            color = 0xff0000;
    }

    boss.traverse(obj => {
        if (obj.isMesh && obj.material) {
            obj.material = obj.material.clone();
            obj.material.color.set(color);
            obj.material.emissive = new THREE.Color(color);
            obj.material.emissiveIntensity = 0.4;
        }
    });
}


   function spawnBoss() {
    // ì´ë¯¸ ë³´ìŠ¤ ìˆìœ¼ë©´ ì¤‘ë³µ ë°©ì§€
    if (state.bossSpawned) return;

    state.bossSpawned = true;

    // ë³´ìŠ¤ ìƒì„±
    boss = createDetailedHumanoid(0xff0000, false, 2.5);

    // ê¸°ë³¸ ìœ„ì¹˜
    boss.position.set(
        player.position.x + 40,
        10,
        player.position.z + 40
    );

    // ë³´ìŠ¤ ìŠ¤íƒ¯
    boss.userData.hp = 3000;
    boss.userData.maxHp = 3000;
    boss.userData.attackTimer = 0;
    boss.userData.phase = 1;
    boss.userData.lastPhase = 0;

       boss.userData.meleeCooldown = 0;
boss.userData.meleeRange = 3.5;
boss.userData.meleeDamage = 12;


    // ë³´ìŠ¤ íƒ€ì… ëœë¤
    const types = ['tank', 'rush', 'summoner'];
    boss.userData.type = types[Math.floor(Math.random() * types.length)];

    // ì™¸í˜• ì ìš©
    applyBossAppearance(boss);

    // ì”¬ ì¶”ê°€
       boss.userData.boxSize = new THREE.Vector3(1.4, 3.2, 1.4);

    scene.add(boss);
boss.userData.velocity.y = 0;
updateGround(boss);

    // ===== UI =====
    document.getElementById('boss-ui').style.display = 'block';
    document.getElementById('boss-hp-fill').style.width = '100%';

    document.getElementById('boss-phase').innerText = 'PHASE 1';

    const msg = document.getElementById('boss-msg');
    msg.innerText = `âš  ${boss.userData.type.toUpperCase()} BOSS âš `;
    msg.style.display = 'block';

    setTimeout(() => {
        msg.style.display = 'none';
    }, 3000);
}



        function spawnDebris(pos, color) {
            for(let i=0; i<8; i++) {
                const m = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.2,0.2), new THREE.MeshBasicMaterial({color:color}));
                m.position.copy(pos); scene.add(m);
                state.debris.push({mesh:m, vel:new THREE.Vector3((Math.random()-0.5), Math.random(), (Math.random()-0.5)), life:40});
            }
        }



function spawnPlayerSafely(player, maxTries = 30) {
    const raycaster = new THREE.Raycaster();
    const spawnRadius = 40;
    const playerRadius = 1;

    for (let i = 0; i < maxTries; i++) {

        // 1ï¸âƒ£ ëœë¤ XZ
        const x = (Math.random() - 0.5) * spawnRadius;
        const z = (Math.random() - 0.5) * spawnRadius;

        // 2ï¸âƒ£ ìœ„ì—ì„œ ì•„ë˜ë¡œ ë ˆì´
        raycaster.set(
            new THREE.Vector3(x, groundY + 100, z),
            new THREE.Vector3(0, -1, 0)
        );

        const hits = raycaster.intersectObjects(colliders.floors, false);
        if (hits.length === 0) continue;

        const y = hits[0].point.y;

        // 3ï¸âƒ£ ì„ì‹œ ìœ„ì¹˜
        const candidate = new THREE.Vector3(x, y + 2, z);

        // 4ï¸âƒ£ ë²½ ì¶©ëŒ ê²€ì‚¬ (Sphere vs Box)
        let blocked = false;
       for (const wall of colliders.walls) {
    if (!wall.userData.box) continue;

    wall.userData.box.copy(wall.geometry.boundingBox)
        .applyMatrix4(wall.matrixWorld);

    if (wall.userData.box.distanceToPoint(candidate) < playerRadius) {
        blocked = true;
        break;
    }
}


        if (blocked) continue;

        // 5ï¸âƒ£ ì„±ê³µ
        player.position.copy(candidate);
        player.userData.velocity.y = 0;
        return true;
    }

    console.warn("ì•ˆì „í•œ ìŠ¤í° ìœ„ì¹˜ë¥¼ ì°¾ì§€ ëª»í•¨");
    return false;
}

       function spawnEnemySafely(enemy, center, maxTries = 40) {
    const raycaster = new THREE.Raycaster();
    const spawnRadius = 60;
    const minWallDistance = 2.2;

    for (let i = 0; i < maxTries; i++) {

        // 1ï¸âƒ£ ì¤‘ì‹¬ì  ê¸°ì¤€ ëœë¤ XZ
        const x = center.x + (Math.random() - 0.5) * spawnRadius;
        const z = center.z + (Math.random() - 0.5) * spawnRadius;

        // 2ï¸âƒ£ ìœ„ì—ì„œ ì•„ë˜ë¡œ ë°”ë‹¥ íƒìƒ‰
        raycaster.set(
            new THREE.Vector3(x, groundY + 120, z),
            new THREE.Vector3(0, -1, 0)
        );

        const hits = raycaster.intersectObjects(colliders.floors, false);
        if (hits.length === 0) continue;

        // ë°”ë‹¥ì˜ ë†’ì´(y) ê°€ì ¸ì˜¤ê¸°
        const y = hits[0].point.y;

        // [í•µì‹¬] ë†’ì´ê°€ ë•…ë°”ë‹¥(groundY)ê³¼ ë‹¤ë¥´ë©´(ì¦‰, ì”í•´ ìœ„ë‚˜ ì˜¥ìƒì´ë©´) ìŠ¤í° í¬ê¸°
        if (Math.abs(y - groundY) > 0.1) {
            continue; 
        }

        const candidate = new THREE.Vector3(x, y + 2, z);

        // 3ï¸âƒ£ ë²½(ê±´ë¬¼ ë³¸ì²´)ê³¼ ê±°ë¦¬ ê²€ì‚¬
        let blocked = false;
        for (const wall of colliders.walls) {
            if (!wall.userData.box) continue;

            wall.userData.box.copy(wall.geometry.boundingBox)
                .applyMatrix4(wall.matrixWorld);

            if (wall.userData.box.distanceToPoint(candidate) < minWallDistance) {
                blocked = true;
                break;
            }
        }

        if (blocked) continue;

        // [ì¶”ê°€] ë°”ë‹¥ì— ìˆëŠ” ì”í•´(ì‘ì€ ë°•ìŠ¤ë“¤) 'ì†'ì— ìƒì„±ë˜ëŠ” ê²ƒ ë°©ì§€
        for (const floorObj of colliders.floors) {
            // ì§„ì§œ ë•…ë°”ë‹¥(ground)ì€ ì œì™¸
            if (floorObj === colliders.floors[0]) continue; 

            if (!floorObj.userData.box) {
                floorObj.geometry.computeBoundingBox();
                floorObj.userData.box = new THREE.Box3().setFromObject(floorObj);
            }
            
            // ì”í•´ ë°•ìŠ¤ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
            const debrisBox = floorObj.userData.box.clone();
            debrisBox.applyMatrix4(floorObj.matrixWorld);

            // ì”í•´ì™€ ê²¹ì¹˜ë©´ blocked ì²˜ë¦¬
            if (debrisBox.distanceToPoint(candidate) < minWallDistance) {
                blocked = true;
                break;
            }
        }

        if (blocked) continue;

        // 4ï¸âƒ£ ì„±ê³µ
        enemy.position.copy(candidate);
        enemy.userData.velocity.y = 0;
        return true;
    }

    console.warn("ì  ì•ˆì „ ìŠ¤í° ì‹¤íŒ¨");
    return false;
}

// í”Œë ˆì´ì–´ ë²½ ì¶©ëŒ ê°ì§€ (Raycaster ë²„ì „ - íšŒì „ëœ ê²½ì‚¬ë¡œ ì •ë°€ ê°ì§€)
function playerIntersectsWall(pos) {
    // í”Œë ˆì´ì–´ì˜ í—ˆë¦¬ ë†’ì´ (ë°”ë‹¥ì—ì„œ ì•½ê°„ ìœ„)
    const rayOrigin = new THREE.Vector3(pos.x, pos.y + 1.0, pos.z);
    
    // 8ë°©í–¥ìœ¼ë¡œ ë ˆì´ì €ë¥¼ ì´ì„œ ë²½ì´ ìˆëŠ”ì§€ ê²€ì‚¬ (ëª¸í†µ ë‘ê»˜ë§Œí¼)
    const directions = [
        new THREE.Vector3(1, 0, 0),  // ìš°
        new THREE.Vector3(-1, 0, 0), // ì¢Œ
        new THREE.Vector3(0, 0, 1),  // ì•
        new THREE.Vector3(0, 0, -1), // ë’¤
        new THREE.Vector3(0.7, 0, 0.7),   // ëŒ€ê°ì„ 
        new THREE.Vector3(-0.7, 0, 0.7),
        new THREE.Vector3(0.7, 0, -0.7),
        new THREE.Vector3(-0.7, 0, -0.7)
    ];

    const wallRay = new THREE.Raycaster();
    const checkRadius = 1.0; // í”Œë ˆì´ì–´ ëª¸í†µ ë°˜ì§€ë¦„ (ì¶©ëŒ ë²”ìœ„)

    // colliders.wallsì— ìˆëŠ” ëª¨ë“  ë¬¼ì²´(ê±´ë¬¼, ê²½ì‚¬ë¡œ) ê²€ì‚¬
    for (const dir of directions) {
        wallRay.set(rayOrigin, dir);
        
        // true: ëª¨ë“  ìì‹ ë©”ì‰¬ê¹Œì§€ ì •ë°€ ê²€ì‚¬
        const hits = wallRay.intersectObjects(colliders.walls, false); 
        
        if (hits.length > 0) {
            // ë ˆì´ì €ê°€ ë‹¿ì•˜ëŠ”ë° ê·¸ ê±°ë¦¬ê°€ ë‚´ ëª¸í†µë³´ë‹¤ ê°€ê¹ë‹¤ë©´ -> ì¶©ëŒ!
            if (hits[0].distance < checkRadius) {
                // ë‹¨, 'ë°”ë‹¥(Floor)' ì†ì„±ì´ ìˆëŠ” ê²½ì‚¬ë¡œë¼ë©´
                // ë‚´ ë°œë³´ë‹¤ í™•ì‹¤íˆ ë‚®ì€ ê³³(ë°Ÿì„ ìˆ˜ ìˆëŠ” ê³³)ì€ ë²½ìœ¼ë¡œ ì¹˜ì§€ ì•ŠìŒ
                // (ê²½ì‚¬ë¡œ ì˜†êµ¬ë¦¬ëŠ” ë²½, ìœ—ë©´ì€ ë°”ë‹¥ìœ¼ë¡œ ì²˜ë¦¬í•˜ê¸° ìœ„í•¨)
                const hitObj = hits[0].object;
                const hitPointY = hits[0].point.y;
                
                // ì¶©ëŒ ì§€ì ì´ ë‚´ ë°œ(pos.y)ë³´ë‹¤ ë†’ìœ¼ë©´ ë²½ì„ (ëª» ì§€ë‚˜ê°)
                // ì¶©ëŒ ì§€ì ì´ ë‚´ ë°œë³´ë‹¤ ë‚®ìœ¼ë©´ ë°Ÿê³  ì§€ë‚˜ê°€ëŠ” ë°”ë‹¥ì„ (ì§€ë‚˜ê°)
                // ì—¬ìœ ê°’ 0.3 (ê³„ë‹¨ í„± ë†’ì´)
                if (hitObj.userData.isFloor && hitPointY <= pos.y + 0.5) {
                    continue; // ë°Ÿê³  ì§€ë‚˜ê°€ë¼
                }

                return true; // ë²½ì— ë§‰í˜
            }
        }
    }

    return false;
}

        
        function resolvePlayerPenetration() {
    const stepUp = 0.12;
    const pushOut = 0.15;

    for (let i = 0; i < 10; i++) {
        if (!playerIntersectsWall(player.position)) return;

        // 1ï¸âƒ£ ìœ„ë¡œ ë°€ê¸° (ì˜¥ìƒ/ë°”ë‹¥ ê²¹ì¹¨)
        player.position.y += stepUp;

        // 2ï¸âƒ£ XZ ëœë¤ ë¯¸ì„¸ ì´ë™ (ë²½ ë‚´ë¶€ íƒˆì¶œ)
        const a = Math.random() * Math.PI * 2;
        player.position.x += Math.cos(a) * pushOut;
        player.position.z += Math.sin(a) * pushOut;
    }
}

        
/* =========================================
   [ì¶”ê°€] ì (Enemy/Boss) ì „ìš© ë¬¼ë¦¬ & ì´ë™ ë¡œì§
   (í”Œë ˆì´ì–´ì™€ ë™ì¼í•œ ë©”ì»¤ë‹ˆì¦˜ ì ìš©)
   ========================================= */

// 1. ì ì˜ ë°”ë‹¥ ê°ì§€ ë° ì¤‘ë ¥ ì ìš© (í”Œë ˆì´ì–´ updateGround + ì¤‘ë ¥ ë¡œì§ í†µí•©)
function applyEnemyPhysics(enemy) {
    // ì¤‘ë ¥ ì ìš©
    if (!enemy.userData.velocity) enemy.userData.velocity = new THREE.Vector3();
    enemy.userData.velocity.y += physics.gravity;
    enemy.position.y += enemy.userData.velocity.y;

    // ë°”ë‹¥ ê°ì§€ (Raycaster)
    // ì í”„ ì¤‘(ìƒìŠ¹ ì¤‘)ì¼ ë•ŒëŠ” ë°”ë‹¥ ë³´ì • ìŠ¤í‚µ
    if (enemy.userData.velocity.y > 0) return;

    const raycaster = new THREE.Raycaster();
    const rayOrigin = enemy.position.clone();
    rayOrigin.y += 1.5; // ë¨¸ë¦¬ ìœ„ì—ì„œ ì‹œì‘

    raycaster.set(rayOrigin, new THREE.Vector3(0, -1, 0));

    // ë°”ë‹¥ë§Œ ê²€ì‚¬
    const hits = raycaster.intersectObjects(colliders.floors, false);

    if (hits.length > 0) {
        const hit = hits[0];
        // í”Œë ˆì´ì–´ì™€ ë™ì¼í•˜ê²Œ 2.0 ê±°ë¦¬ ë‚´ ë°”ë‹¥ ìŠ¤ëƒ…
        if (hit.distance < 2.0) {
            enemy.position.y = hit.point.y;
            enemy.userData.velocity.y = 0;
            enemy.userData.isGrounded = true;
            return;
        }
    }

    // ë°”ë‹¥ ì—†ìœ¼ë©´ ê³µì¤‘ ìƒíƒœ
    if (enemy.position.y <= groundY) {
        enemy.position.y = groundY;
        enemy.userData.velocity.y = 0;
        enemy.userData.isGrounded = true;
    } else {
        enemy.userData.isGrounded = false;
    }
}

// 2. ì ì˜ ë²½ ì¶©ëŒ ê°ì§€ (í”Œë ˆì´ì–´ playerIntersectsWallê³¼ ë™ì¼)
function enemyIntersectsWall(enemy) {
    const rayOrigin = new THREE.Vector3(enemy.position.x, enemy.position.y + 1.0, enemy.position.z);
    
    const directions = [
        new THREE.Vector3(1, 0, 0), new THREE.Vector3(-1, 0, 0),
        new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, -1),
        new THREE.Vector3(0.7, 0, 0.7), new THREE.Vector3(-0.7, 0, 0.7),
        new THREE.Vector3(0.7, 0, -0.7), new THREE.Vector3(-0.7, 0, -0.7)
    ];

    const wallRay = new THREE.Raycaster();
    // ì ì˜ í¬ê¸°(ë°•ìŠ¤ ì‚¬ì´ì¦ˆ)ì— ë”°ë¼ ì²´í¬ ë°˜ì§€ë¦„ ì¡°ì • (ë³´ìŠ¤ëŠ” ë” í¬ê²Œ)
    // ê¸°ë³¸ ì : 0.8 -> ë°˜ì§€ë¦„ ì•½ 0.5~0.6
    // ë³´ìŠ¤: 1.4 -> ë°˜ì§€ë¦„ ì•½ 1.0
    const checkRadius = enemy.userData.boxSize ? Math.max(enemy.userData.boxSize.x, enemy.userData.boxSize.z) * 0.6 : 0.6;

    for (const dir of directions) {
        wallRay.set(rayOrigin, dir);
        const hits = wallRay.intersectObjects(colliders.walls, false);
        
        if (hits.length > 0) {
            if (hits[0].distance < checkRadius) {
                // ê²½ì‚¬ë¡œ(Floor) ë¬´ì‹œ ë¡œì§
                const hitObj = hits[0].object;
                const hitPointY = hits[0].point.y;
                if (hitObj.userData.isFloor && hitPointY <= enemy.position.y + 0.5) {
                    continue;
                }
                return true; // ë²½ ì¶©ëŒ
            }
        }
    }
    return false;
}

// 3. ì  ì´ë™ í•¨ìˆ˜ (í”Œë ˆì´ì–´ì™€ ë˜‘ê°™ì´ X/Z ë¶„ë¦¬ ì´ë™ + ë²½ íƒ€ê¸°)
function moveEnemyLikePlayer(enemy, targetPos, speed) {
    // ì´ë™ ë°©í–¥ ê³„ì‚° (Yì¶• ì œì™¸)
    const direction = new THREE.Vector3()
        .subVectors(targetPos, enemy.position);
    direction.y = 0;
    direction.normalize();

    // ì´ë™ ë²¡í„°
    const moveX = direction.x * speed;
    const moveZ = direction.z * speed;

    // 1) Xì¶• ì´ë™ ì‹œë„
    const oldX = enemy.position.x;
    enemy.position.x += moveX;
    if (enemyIntersectsWall(enemy)) {
        enemy.position.x = oldX; // ë§‰íˆë©´ ì·¨ì†Œ
    }

    // 2) Zì¶• ì´ë™ ì‹œë„ (ë…ë¦½ì )
    const oldZ = enemy.position.z;
    enemy.position.z += moveZ;
    if (enemyIntersectsWall(enemy)) {
        enemy.position.z = oldZ; // ë§‰íˆë©´ ì·¨ì†Œ
    }

    // 3) íšŒì „ (ë°”ë¼ë³´ê¸°)
    // ë³´ìŠ¤ë‚˜ ì ì´ ì´ë™í•  ë•Œ ìì—°ìŠ¤ëŸ½ê²Œ íƒ€ê²Ÿì„ ë´„
    enemy.lookAt(targetPos.x, enemy.position.y, targetPos.z);
}

        
    function animate() {
    requestAnimationFrame(animate);

    if (!state.isGameActive || state.isGameOver) return;

    // 1. ì‹œê°„ & ë¸íƒ€
    const dt = clock.getDelta();
    const time = clock.getElapsedTime();

    // 2. í™˜ê²½/í”Œë ˆì´ì–´
   // í”Œë ˆì´ì–´ ìœ„ì¹˜ì— ë”°ë¼ ì£¼ë³€ ë„ì‹œ ìƒì„±
    const playerX = camera.position.x;
    const playerZ = camera.position.z;
    updateCity(player.position.x, player.position.z);
    if (!player.userData.isGrounded) updateGround(player);

    // 3. í”Œë ˆì´ì–´ ì´ì•Œ ì—°ì‚¬
    // 3. í”Œë ˆì´ì–´ ì´ì•Œ ì—°ì‚¬ (ë ˆì´ìºìŠ¤íŒ… ì •ë°€ ì‚¬ê²© + ë²½ ë§‰í˜ ë°©ì§€)
    if (isFiring && fireCooldown <= 0) { 
        // (1) í™”ë©´ ì •ì¤‘ì•™(í¬ë¡œìŠ¤í—¤ì–´)ì´ ë¬´ì—‡ì„ ê°€ë¦¬í‚¤ëŠ”ì§€ í™•ì¸
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

        // ë¶€ë”ªíˆëŠ” ëª¨ë“  ê²ƒ(ë²½, ë°”ë‹¥, ì ) ê²€ì‚¬
        // colliders.walls(ë²½), colliders.floors(ë°”ë‹¥), state.enemies(ì ) ëª¨ë‘ í¬í•¨
        const targetObjects = [...colliders.walls, ...colliders.floors];
        state.enemies.forEach(e => targetObjects.push(e));
        if(boss) targetObjects.push(boss);

        const hits = raycaster.intersectObjects(targetObjects, false); // ìì‹ê¹Œì§€ ê²€ì‚¬í•˜ë ¤ë©´ true, ì„±ëŠ¥ ìœ„í•´ false ê¶Œì¥ (ì ì€ ë°•ìŠ¤ë§Œ ì²´í¬ ë“±)
        
        // ëª©í‘œ ì§€ì  ê³„ì‚° (ë§ì€ê²Œ ìˆìœ¼ë©´ ê·¸ê³³, ì—†ìœ¼ë©´ í—ˆê³µ ë©€ë¦¬)
        let targetPoint;
        if (hits.length > 0) {
            targetPoint = hits[0].point;
        } else {
            // í—ˆê³µì„ ì˜ë©´ ì¹´ë©”ë¼ ì• 100ë¯¸í„° ì§€ì 
            targetPoint = raycaster.ray.origin.clone().add(raycaster.ray.direction.multiplyScalar(100));
        }

        // (2) ì´ì•Œ ì‹œì‘ ìœ„ì¹˜ ê²°ì • (ì˜¤ë¥¸ì†ì¡ì´ ëŠë‚Œ)
        // ì¹´ë©”ë¼ ìœ„ì¹˜ì—ì„œ ì‹œì‘í•˜ë˜, ì˜¤ë¥¸ìª½(Right) ì•„ë˜(Down) ì•(Forward)ìœ¼ë¡œ ì‚´ì§ ì´ë™
        const spawnPos = camera.position.clone();
        
        // ì¹´ë©”ë¼ ê¸°ì¤€ ë°©í–¥ ë²¡í„°
        const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
        const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
        const up = new THREE.Vector3(0, 1, 0).applyQuaternion(camera.quaternion);

        // ê¸°ë³¸ ì´êµ¬ ìœ„ì¹˜: ì˜¤ë¥¸ìª½ 0.5, ì•„ë˜ 0.3, ì• 0.5 (ì˜¤ë¥¸ìª½ ì–´ê¹¨ ê²¬ì°© ëŠë‚Œ)
        // TPS ëª¨ë“œì¼ ë•ŒëŠ” í”Œë ˆì´ì–´ ëª¸ì—ì„œ ë‚˜ê°€ëŠ” ê²ƒì²˜ëŸ¼ ì¡°ì •
        if (!isMobile) { 
             spawnPos.add(right.multiplyScalar(0.4)).add(up.multiplyScalar(-0.2)).add(forward.multiplyScalar(0.5));
        } else {
             // ëª¨ë°”ì¼(Top View) ë“±ì—ì„œëŠ” í”Œë ˆì´ì–´ ëª¸í†µ ì¤‘ì‹¬ì—ì„œ ë°œì‚¬
             spawnPos.copy(player.position).add(new THREE.Vector3(0, 1.5, 0)).add(forward.multiplyScalar(0.5));
        }

        // (3) [í•µì‹¬] ë²½ì— ë„ˆë¬´ ê°€ê¹Œì›Œì„œ ì´êµ¬ê°€ íŒŒë¬»íˆëŠ”ì§€ ê²€ì‚¬
        // ì¹´ë©”ë¼ì™€ ëª©í‘œì§€ì  ì‚¬ì´ì˜ ê±°ë¦¬ê°€ ë„ˆë¬´ ê°€ê¹Œìš°ë©´(ë²½ì— ë¶™ìŒ), ì´ì•Œì„ ì¹´ë©”ë¼ ë°”ë¡œ ì•ì—ì„œ ìƒì„±
        if (hits.length > 0 && hits[0].distance < 1.0) {
            // ë²½ì— ì–¼êµ´ì„ ëŒ€ê³  ì˜ëŠ” ê²½ìš° -> ì¹´ë©”ë¼ ìœ„ì¹˜ì—ì„œ ë°”ë¡œ ë°œì‚¬ (ëš«ë¦¼ ë°©ì§€)
            spawnPos.copy(camera.position).add(forward.multiplyScalar(0.2)); 
        }

        // (4) ë°œì‚¬ ë°©í–¥ ê³„ì‚° (ì‹œì‘ì  -> ëª©í‘œì )
        const fireDir = new THREE.Vector3().subVectors(targetPoint, spawnPos).normalize();

        // (5) ë°œì‚¬ í•¨ìˆ˜ í˜¸ì¶œ (ì†ë„ 2.5ë¡œ ë¹ ë¥´ê²Œ)
        fireBullet(false, spawnPos, fireDir, 2.5);

        fireCooldown = 6; // ì—°ì‚¬ ì†ë„
    }
    
    if (fireCooldown > 0) fireCooldown--;

    // 4. ì¹´ë©”ë¼ ì—…ë°ì´íŠ¸
    const targetPos = player.position.clone().add(new THREE.Vector3(0, 1.6, 0));
    if (!isMobile) {
        const currentRadius = state.cameraMode === 'TPS' ? state.cam.radius : 0.1;
        const offsetX = currentRadius * Math.sin(state.cam.phi) * Math.sin(state.cam.theta);
        const offsetY = currentRadius * Math.cos(state.cam.phi);
        const offsetZ = currentRadius * Math.sin(state.cam.phi) * Math.cos(state.cam.theta);
        camera.position.copy(targetPos).add(new THREE.Vector3(offsetX, offsetY, offsetZ));
        camera.lookAt(targetPos);
        player.rotation.y = state.cam.theta + Math.PI;
    } else {
        camera.position.lerp(player.position.clone().add(new THREE.Vector3(0, 15, 12)), 0.1);
        camera.lookAt(player.position);
    }

    // 5. í”Œë ˆì´ì–´ ì´ë™
    const fwd = new THREE.Vector3(0,0,1).applyAxisAngle(new THREE.Vector3(0,1,0), player.rotation.y);
    const right = new THREE.Vector3(-1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), player.rotation.y);
    const move = new THREE.Vector3();
    if (input.w) move.add(fwd); if (input.s) move.sub(fwd);
    if (input.d) move.add(right); if (input.a) move.sub(right);
    if (isMobile && (input.joyX || input.joyY)) {
        move.set(input.joyX,0,input.joyY);
        if(move.lengthSq()>0.01) player.rotation.y = -Math.atan2(input.joyY,input.joyX)+Math.PI/2;
    }
    move.normalize().multiplyScalar(0.25);
  // X ì´ë™ ë¨¼ì €
player.position.x += move.x;
if (playerIntersectsWall(player.position)) {
    player.position.x -= move.x;
}

// Z ì´ë™ ë‹¤ìŒ
player.position.z += move.z;
if (playerIntersectsWall(player.position)) {
    player.position.z -= move.z;
}



    // 6. ì í”„ & ì¤‘ë ¥
    if (input.space && player.userData.isGrounded) {
        player.userData.velocity.y = physics.jump;
        player.userData.isGrounded = false;
    }
   // 1. ì¤‘ë ¥
player.userData.velocity.y += physics.gravity;

// 2. ì´ë™
player.position.y += player.userData.velocity.y;

// 3. ì¦‰ì‹œ ë°”ë‹¥ ë³´ì •
updateGround(player);


    // 7. ì´ì•Œ ì—…ë°ì´íŠ¸
    for (let i = state.bullets.length-1; i>=0; i--) {
        const b = state.bullets[i];
        b.mesh.position.add(b.velocity);
        b.life--;
        let hit=false;

        // ë²½ ì¶©ëŒ
        if(!hit) {
            for (const wall of colliders.walls) {
                wall.userData.box.copy(wall.geometry.boundingBox).applyMatrix4(wall.matrixWorld);
                if (wall.userData.box.containsPoint(b.mesh.position)) { hit=true; break; }
            }
        }

        // ì /í”Œë ˆì´ì–´ ì¶©ëŒ
        if(!hit) {
            if(b.isEnemy) {
                if(b.mesh.position.distanceTo(player.position.clone().add(new THREE.Vector3(0,1,0)))<1.0){
                    state.hp-=10; hit=true;
                    document.getElementById('damage-overlay').style.opacity=0.6;
                    setTimeout(()=>document.getElementById('damage-overlay').style.opacity=0,200);
                }
            } else {
                // ì¼ë°˜ ì 
                for(let j=state.enemies.length-1;j>=0;j--){
                    if(state.enemies[j].position.distanceTo(b.mesh.position)<1.5){
                        spawnDebris(state.enemies[j].position,0xff4444);
                        if(state.enemies[j].userData.isGunner) state.gunnerCount--;
                        scene.remove(state.enemies[j]); state.enemies.splice(j,1);
                        state.score+=100; hit=true; break;
                    }
                }
                // ë³´ìŠ¤
                if(!hit && boss && boss.position.distanceTo(b.mesh.position)<4){
                    boss.userData.hp-=20; hit=true;
                    spawnDebris(b.mesh.position,0xff0000);
                    document.getElementById('boss-hp-fill').style.width=(boss.userData.hp/boss.userData.maxHp*100)+'%';
                    if(boss.userData.hp<=0){
                        scene.remove(boss);
                        state.hp=Math.min(state.hp+20,100);
                        boss=null; state.bossSpawned=false;
                        document.getElementById('boss-ui').style.display='none';
                    }
                }
            }
        }

        if(hit || b.life<=0){ scene.remove(b.mesh); state.bullets.splice(i,1); }
    }

    // 8. ë³´ìŠ¤ í˜ì´ì¦ˆ & UI
    if(boss){
        const hpRate = boss.userData.hp / boss.userData.maxHp;
        boss.userData.phase = hpRate<=0.3?3: hpRate<=0.7?2:1;

        if(boss.userData.lastPhase!==boss.userData.phase){
            boss.userData.lastPhase=boss.userData.phase;
            document.getElementById('boss-phase').innerText=`PHASE ${boss.userData.phase}`;
            const fill = document.getElementById('boss-hp-fill');
            fill.style.background = boss.userData.phase===1?'linear-gradient(90deg,#ff5555,#ff2222)':
                                   boss.userData.phase===2?'linear-gradient(90deg,#ffaa00,#ff7700)':
                                   'linear-gradient(90deg,#aa00ff,#ff00aa)';
            const msg = document.getElementById('boss-msg');
            msg.innerText=`âš  PHASE ${boss.userData.phase} âš `;
            msg.style.display='block';
            setTimeout(()=>msg.style.display='none',1500);
        }
    }

    // 9. ì /ë³´ìŠ¤ ìŠ¤í° & AI
    if(state.score>=state.nextBossScore && !state.bossSpawned){ spawnBoss(); state.nextBossScore+=5000; }
   if (!boss && state.enemies.length < 16 && Math.random() < 0.005) {
  // ì  ìƒì„± í›„
const e = createDetailedHumanoid(0xff4444, false); // ì¼ë°˜ ì  ë¹¨ê°•
e.userData.boxSize = new THREE.Vector3(0.8, 1.8, 0.8);

// Gunner ì—¬ë¶€ ì„¤ì • (ëœë¤ ë˜ëŠ” ì›í•˜ëŠ” ê¸°ì¤€)
e.userData.shootCooldown = Math.random() * 1.5; // ì´ˆê¸°ê°’ ëœë¤
e.userData.isGunner = Math.random() < 0.3; // 30% í™•ë¥ ë¡œ Gunner

// Gunner ìƒ‰ìƒ ë³€ê²½
if (e.userData.isGunner) {
    e.traverse(obj => {
        if (obj.isMesh && obj.material) {
            obj.material = obj.material.clone();
            obj.material.color.set(0xff8800); // ì£¼í™©ìƒ‰
        }
    });
}

// ì”¬ì— ì¶”ê°€
scene.add(e);
if (spawnEnemySafely(e, player.position)) {
    state.enemies.push(e);
} else {
    scene.remove(e); // ì‹¤íŒ¨ ì‹œ ì œê±°
}


}


// ... (animate í•¨ìˆ˜ ë‚´ë¶€) ...

    const allEnemies = [...state.enemies]; if(boss) allEnemies.push(boss);
    allEnemies.forEach(e => {
        
        // 1ï¸âƒ£ ë¬¼ë¦¬ ì—…ë°ì´íŠ¸ (ì¤‘ë ¥ + ë°”ë‹¥ ê°ì§€) - í”Œë ˆì´ì–´ì™€ ë™ì¼í•˜ê²Œ ì ìš©
        applyEnemyPhysics(e);

        const dist = e.position.distanceTo(player.position);
        
        // Gunner ê³µê²© ë¡œì§ (ê¸°ì¡´ ìœ ì§€)
        if(e!==boss && e.userData.isGunner){
            e.userData.shootCooldown -= dt;
            if(e.userData.shootCooldown<=0){
                const dir=new THREE.Vector3().subVectors(player.position,e.position).normalize();
                fireBullet(true,e.position.clone().add(new THREE.Vector3(0,1.6,0)),dir);
                e.userData.shootCooldown=4;
            }
        }

        // 2ï¸âƒ£ ì´ë™ ë¡œì§ (í”Œë ˆì´ì–´ ë°©ì‹ ì ìš©: ë²½ íƒ€ê¸° + Raycaster ì¶©ëŒ)
        const attackRange = (e === boss) ? 8 : 1.2; // ê³µê²© ì‚¬ê±°ë¦¬
        
        // ì‚¬ê±°ë¦¬ë³´ë‹¤ ë©€ë©´ ì¶”ê²©
        if (dist > attackRange) {
            const speed = (e === boss) ? 0.06 : 0.1; // ì´ë™ ì†ë„
            // ê¸°ì¡´ì˜ ë‹¨ìˆœ add ì´ë™ ëŒ€ì‹ , ì•„ê¹Œ ë§Œë“  moveEnemyLikePlayer ì‚¬ìš©
            moveEnemyLikePlayer(e, player.position, speed);
        } else {
            // ì‚¬ê±°ë¦¬ ì•ˆì´ë©´ ì œìë¦¬ì—ì„œ í”Œë ˆì´ì–´ ë°”ë¼ë³´ê¸°
            e.lookAt(player.position.x, e.position.y, player.position.z);
        }

        // 3ï¸âƒ£ ë³´ìŠ¤ íŒ¨í„´ (ê¸°ì¡´ ìœ ì§€)
        if(e===boss){
            e.userData.attackTimer += dt;
            const distToPlayer = e.position.distanceTo(player.position);
            
            // ê·¼ì ‘ ê³µê²©
            if(distToPlayer < e.userData.meleeRange){
                e.userData.meleeCooldown -= dt;
                if(e.userData.meleeCooldown<=0){
                    state.hp-=e.userData.meleeDamage*e.userData.phase;
                    const knockDir=new THREE.Vector3().subVectors(player.position,e.position).normalize().multiplyScalar(0.8);
                    player.position.add(knockDir);
                    const overlay=document.getElementById('damage-overlay');
                    overlay.style.opacity=0.7; setTimeout(()=>overlay.style.opacity=0,200);
                    e.userData.meleeCooldown=1.2;
                    e.userData.rArm.root.rotation.x=-1.5;
                    setTimeout(()=>{e.userData.rArm.root.rotation.x=0;},200);
                }
            }

            // íŠ¹ìˆ˜ íŒ¨í„´ (Rush íƒ€ì…ì˜ ì´ë™ ë¶€ë¶„ë§Œ ìˆ˜ì • í•„ìš”)
            const phase=e.userData.phase;
            const type=e.userData.type;
            const attackDelay = phase===1?2.5:phase===2?1.6:0.9;
            
            if(e.userData.attackTimer>attackDelay){
                e.userData.attackTimer=0;
                if(type==='tank'){ 
                    const count = phase===1?6:phase===2?10:16; const spread=Math.PI/3;
                    for(let i=0;i<count;i++){
                        const angle=-spread/2+(spread/count)*i+e.rotation.y;
                        fireBullet(true,e.position.clone().add(new THREE.Vector3(0,1.6,0)),
                                   new THREE.Vector3(Math.sin(angle),0,Math.cos(angle)));
                    }
                }
                if(type==='rush'){
                    // [ìˆ˜ì •] Rush íŒ¨í„´ë„ ë¬¼ë¦¬ ì—”ì§„ ì ìš© ì´ë™ ì‚¬ìš©
                    // ìˆœê°„ì´ë™ì´ë‚˜ ë‹¨ìˆœ add ëŒ€ì‹  ë¹ ë¥´ê²Œ ì´ë™í•˜ë„ë¡ ì²˜ë¦¬
                    // ì—¬ê¸°ì„œëŠ” ê°„ë‹¨íˆ í”Œë ˆì´ì–´ ë°©í–¥ìœ¼ë¡œ 3ë°° ì†ë„ë¡œ ì´ë™ ì‹œë„
                    // (í•œ í”„ë ˆì„ì— 3ë°°ë¥¼ ê°€ëŠ”ê²Œ ì•„ë‹ˆë¼, ëŒì§„ ëª©í‘œ ì§€ì ì„ ì„¤ì •í•˜ëŠ”ê²Œ ì¢‹ì§€ë§Œ,
                    // ê¸°ì¡´ ë¡œì§ì„ ìµœëŒ€í•œ ìœ ì§€í•˜ë©´ì„œ ë¬¼ë¦¬ ì ìš©í•˜ë ¤ë©´ ì•„ë˜ì²˜ëŸ¼ ë³€ê²½)
                    
                    const rushSpeed = 2.0; // ëŒì§„ ì†ë„
                    // ëŒì§„ì€ í•œ ë²ˆì— íŒ ê°€ëŠ”ê²Œ ì•„ë‹ˆë¼ ì§€ì†ì ìœ¼ë¡œ ê°€ì•¼ í•˜ì§€ë§Œ,
                    // ê¸°ì¡´ ì½”ë“œê°€ 'ìˆœê°„ ì´ë™' ë°©ì‹ì´ì—ˆìœ¼ë¯€ë¡œ, ì—¬ê¸°ì„œëŠ” 
                    // "ë²½ ëš«ì§€ ì•Šê³  ìµœëŒ€í•œ ë©€ë¦¬ ê°€ê¸°"ë¡œ êµ¬í˜„
                    
                    const dir = new THREE.Vector3().subVectors(player.position, e.position).normalize();
                    const target = e.position.clone().add(dir.multiplyScalar(phase * 3));
                    
                    // ëŒì§„ë„ ë²½ ê²€ì‚¬ í•˜ë©´ì„œ ì´ë™
                    moveEnemyLikePlayer(e, target, 1.0); // 1.0ì€ ê±°ë¦¬ ë¹„ìœ¨ (ì¦‰ì‹œ ì´ë™)
                    // ì£¼ì˜: moveEnemyLikePlayerëŠ” ì†ë„(speed)ë¥¼ ë”í•˜ëŠ” ë°©ì‹ì´ë¼
                    // ìˆœê°„ì´ë™ì„ ì›í•˜ë©´ ë°˜ë³µë¬¸ìœ¼ë¡œ ì—¬ëŸ¬ë²ˆ í˜¸ì¶œí•˜ê±°ë‚˜ ë¡œì§ì„ ë°”ê¿”ì•¼ í•¨.
                    // ì—¬ê¸°ì„œëŠ” ì•ˆì „í•˜ê²Œ "ê°•ë ¥í•œ í•œ ê±¸ìŒ"ìœ¼ë¡œ ëŒ€ì²´
                }
               if(type === 'summoner'){
    // [ì„¤ëª…] í˜ì´ì¦ˆ 1,2ë©´ 1ë§ˆë¦¬, í˜ì´ì¦ˆ 3ì´ë©´ 2ë§ˆë¦¬ ì†Œí™˜
    for(let i = 0; i < (phase === 3 ? 2 : 1); i++){
        
        // 1. ì ì´ ë„ˆë¬´ ë§ìœ¼ë©´ ì†Œí™˜ ì¤‘ë‹¨ (ë ‰ ë°©ì§€)
        if(state.enemies.length >= 8) break;

        const minion = createDetailedHumanoid(0xff7777, false); // ê¸°ë³¸ì€ ë¶„í™ìƒ‰
        
        // 2. ìœ„ì¹˜ ì„¤ì • (ë³´ìŠ¤ ì£¼ë³€)
        minion.position.copy(e.position).add(new THREE.Vector3((Math.random()-0.5)*6, 0, (Math.random()-0.5)*6));
        
        // 3. Gunner ì†ì„± ë¶€ì—¬
        minion.userData.isGunner = true;
        minion.userData.shootCooldown = 1.5;

        // [ì¶”ê°€] Gunnerë‹ˆê¹Œ ì£¼í™©ìƒ‰ìœ¼ë¡œ ì˜· ê°ˆì•„ì…íˆê¸° (í”Œë ˆì´ì–´ ì‹ë³„ìš©)
        minion.traverse(obj => {
            if (obj.isMesh && obj.material) {
                obj.material = obj.material.clone();
                obj.material.color.set(0xff8800); // ì£¼í™©ìƒ‰
            }
        });

        scene.add(minion);
        state.enemies.push(minion);
        state.gunnerCount++;
    }
}
                if(phase===3) camera.position.add(new THREE.Vector3((Math.random()-0.5)*0.4,(Math.random()-0.5)*0.4,0));
            }
        } else { 
            // ì¼ë°˜ ì  ê·¼ì ‘ ë°ë¯¸ì§€
            if(dist < 1.2){ 
                state.hp -= 0.5; 
                document.getElementById('damage-overlay').style.opacity=0.3; 
            } 
        }

        // ì• ë‹ˆë©”ì´ì…˜ (ê¸°ì¡´ ìœ ì§€)
        const anim = time*(e===boss?4:10);
        e.userData.lArm.root.rotation.x=-Math.sin(anim);
        e.userData.rArm.root.rotation.x=Math.sin(anim);
        e.userData.lLeg.root.rotation.x=Math.sin(anim);
        e.userData.rLeg.root.rotation.x=-Math.sin(anim);
    });

    // 10. ê²Œì„ì˜¤ë²„
    if(state.hp<=0){
        state.isGameOver=true;
        document.getElementById('game-over').style.display='flex';
        document.getElementById('final-score').innerText=state.score;
        document.exitPointerLock();
    }

    // 11. íŒŒí¸(ë°ë¸Œë¦¬)
    for(let i=state.debris.length-1;i>=0;i--){
        const d=state.debris[i];
        d.mesh.position.add(d.vel);
        d.vel.y-=0.02;
        d.life--;
        if(d.life<=0){ scene.remove(d.mesh); state.debris.splice(i,1); }
    }

    // 12. UI ì—…ë°ì´íŠ¸ & í”Œë ˆì´ì–´ ì• ë‹ˆë©”ì´ì…˜
    document.getElementById('hp-bar').innerText=`HP: ${Math.floor(state.hp)}`;
    document.getElementById('score-bar').innerText=`SCORE: ${state.score}`;
    if(input.w||input.s||input.a||input.d || (isMobile&&(input.joyX||input.joyY))){
        const at=time*15;
        player.userData.lArm.root.rotation.x=-Math.sin(at);
        player.userData.rArm.root.rotation.x=Math.sin(at);
        player.userData.lLeg.root.rotation.x=Math.sin(at);
        player.userData.rLeg.root.rotation.x=-Math.sin(at);
    }

    // 13. ë Œë”ë§
    renderer.render(scene,camera);
}

animate();

        window.addEventListener('resize', () => { camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    </script>
</body>
</html>
